{"version":3,"file":"webxr.js","sourceRoot":"","sources":["../../src/types/webxr.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;GAaG","sourcesContent":["/* @license\n * Copyright 2019 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\ndeclare type Constructor<T = object> = {\n  new (...args: any[]): T,\n  prototype: T\n};\n\ndeclare type XRReferenceSpaceType =\n    'local' | 'local-floor' | 'bounded-floor' | 'unbounded' | 'viewer';\n\ndeclare type XRSessionMode = 'inline' | 'immersive-ar' | 'immersive-vr';\n\ndeclare interface XRPresentationContext {\n  readonly canvas: HTMLCanvasElement;\n}\n\ndeclare interface XRHitTestSource {\n  cancel(): void;\n}\n\ndeclare interface XRTransientInputHitTestSource {\n  cancel(): void;\n}\n\ndeclare interface XRHitTestResult {\n  getPose(baseSpace: XRSpace): XRPose|null;\n}\n\ndeclare interface XRTransientInputHitTestResult {\n  readonly inputSource: XRInputSource;\n  readonly results: Array<XRHitTestResult>;\n}\n\ndeclare interface XR extends EventTarget {\n  requestSession(mode: XRSessionMode, options?: any): Promise<XRSession>;\n  isSessionSupported(mode: XRSessionMode): Promise<boolean>;\n}\n\ndeclare interface XRRigidTransform {\n  readonly position: DOMPointReadOnly;\n  readonly orientation: DOMPointReadOnly;\n  readonly matrix: Float32Array;\n  readonly inverse: XRRigidTransform;\n}\n\ndeclare interface XRSpace extends EventTarget {}\n\ndeclare interface XRReferenceSpace extends XRSpace {\n  getOffsetReferenceSpace(originOffset: XRRigidTransform): XRReferenceSpace;\n}\n\ntype XREye = 'left'|'right';\n\ndeclare interface XRView {\n  readonly eye: XREye;\n  readonly projectionMatrix: Float32Array;\n  readonly viewMatrix: Float32Array;\n  readonly transform: XRRigidTransform;\n  readonly recommendedViewportScale: number|null;\n  requestViewportScale(scale: number|null): void;\n}\n\ndeclare interface XRViewerPose {\n  readonly transform: XRRigidTransform;\n  readonly views: Array<XRView>\n}\n\ndeclare interface XRRayDirectionInit {\n  x?: number;\n  y?: number;\n  z?: number;\n  w?: number;\n}\n\ndeclare class XRRay {\n  readonly origin: DOMPointReadOnly;\n  readonly direction: XRRayDirectionInit;\n  matrix: Float32Array;\n\n  constructor(origin: DOMPointInit, direction: XRRayDirectionInit)\n}\n\ndeclare interface XRPose {\n  readonly emulatedPosition: boolean;\n  readonly transform: XRRigidTransform;\n}\n\ntype XRHandedness = ''|'left'|'right';\ntype XRTargetRayMode = 'gaze'|'tracked-pointer'|'screen';\n\ndeclare interface XRInputSource {\n  readonly handedness: XRHandedness;\n  readonly targetRayMode: XRTargetRayMode;\n  readonly targetRaySpace: XRSpace;\n  readonly gripSpace?: XRSpace;\n  readonly profiles: Array<String>;\n  readonly gamepad: Gamepad;\n}\n\ndeclare interface XRInputSourceEvent extends Event {\n  readonly frame: XRFrame;\n  readonly inputSource: XRInputSource;\n}\n\ndeclare interface XRFrame {\n  readonly session: XRSession;\n  getViewerPose(referenceSpace?: XRReferenceSpace): XRViewerPose;\n  getPose(space: XRSpace, referenceSpace: XRReferenceSpace): XRPose;\n  getHitTestResults(hitTestSource: XRHitTestSource): Array<XRHitTestResult>;\n  getHitTestResultsForTransientInput(hitTestSource:\n                                         XRTransientInputHitTestSource):\n      Array<XRTransientInputHitTestResult>;\n}\n\ntype XRFrameRequestCallback = (time: number, frame: XRFrame) => void;\n\ndeclare interface XRRenderState {\n  readonly depthNear: number;\n  readonly depthFar: number;\n  readonly inlineVerticalFieldOfView?: number;\n  readonly baseLayer?: XRWebGLLayer;\n}\n\ndeclare interface XRRenderStateInit {\n  depthNear?: number;\n  depthFar?: number;\n  inlineVerticalFieldOfView?: number;\n  baseLayer?: XRWebGLLayer;\n}\n\ndeclare interface XRHitTestOptionsInit {\n  space: XRSpace;\n  offsetRay?: XRRay;\n}\n\ndeclare interface XRTransientInputHitTestOptionsInit {\n  profile: string;\n  offsetRay?: XRRay;\n}\n\ndeclare interface XRSession extends EventTarget {\n  renderState: XRRenderState;\n  updateRenderState(state?: XRRenderStateInit): any;\n  requestReferenceSpace(type: XRReferenceSpaceType): Promise<XRReferenceSpace>;\n  requestHitTestSource(options: XRHitTestOptionsInit): Promise<XRHitTestSource>;\n  requestHitTestSourceForTransientInput(options:\n                                            XRTransientInputHitTestOptionsInit):\n      Promise<XRTransientInputHitTestSource>;\n  inputSources: Array<XRInputSource>;\n  requestAnimationFrame(callback: XRFrameRequestCallback): number;\n  cancelAnimationFrame(id: number): void;\n  end(): Promise<void>;\n}\n\ndeclare interface XRViewport {\n  readonly x: number;\n  readonly y: number;\n  readonly width: number;\n  readonly height: number;\n}\n\ndeclare interface XRLayer {}\n\ndeclare interface XRWebGLLayerInit {\n  antialias?: boolean;\n  depth?: boolean;\n  stencil?: boolean;\n  alpha?: boolean;\n  ignoreDepthValues?: boolean;\n  framebufferScaleFactor?: number;\n}\n\ndeclare class XRWebGLLayer implements XRLayer {\n  public framebuffer: WebGLFramebuffer;\n  public framebufferWidth: number;\n  public framebufferHeight: number;\n\n  constructor(\n      session: XRSession, gl: WebGLRenderingContext, options: XRWebGLLayerInit)\n\n  getViewport(view: XRView): XRViewport\n}\n\ndeclare interface Window {\n  XRSession?: Constructor<XRSession>;\n  XR?: Constructor<XR>;\n}\n\ndeclare interface Navigator {\n  xr?: XR;\n}\n\ndeclare interface WebGLRenderingContext {\n  makeXRCompatible(): Promise<void>;\n}\n"]}