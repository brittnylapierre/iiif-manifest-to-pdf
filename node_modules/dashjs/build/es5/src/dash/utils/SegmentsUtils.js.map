{"version":3,"sources":["../../../../../src/dash/utils/SegmentsUtils.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;qkBA+BoB,iBAAiB,qDAErC,SAAS,eAAe,CAAC,MAAM,CAAE,YAAY,CAAE,CAC3C,MAAO,MAAM,CAAC,MAAM,GAAG,YAAY,EAAE,CACjC,MAAM,GAAG,GAAG,GAAG,MAAM,CAAC,CACzB,AACD,OAAO,MAAM,CAAC,CACjB,AAED,SAAS,mBAAmB,CAAC,OAAO,CAAE,YAAY,CAAE,CAChD,OAAO,OAAO,CAAC,cAAc,CAAC,WAAW,GAAG,YAAY,CAAC,CAC5D,AAEM,SAAS,yBAAyB,CAAC,GAAG,CAAE,CAC3C,OAAO,GAAG,CAAG,GAAG,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,CAAG,GAAG,CAAC,CAChD,AAEM,SAAS,oBAAoB,CAAC,GAAG,CAAE,KAAK,CAAE,CAC7C,GAAI,CAAC,KAAK,IAAI,CAAC,GAAG,IAAI,GAAG,CAAC,OAAO,CAAC,oBAAoB,CAAC,KAAK,CAAC,CAAC,CAAE,CAAE,OAAO,GAAG,CAAC,CAAE,AAC/E,IAAI,CAAC,CAAG,KAAK,CAAC,QAAQ,EAAE,CAAC,AACzB,OAAO,GAAG,CAAC,KAAK,CAAC,oBAAoB,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,CAAC,CAClD,AAEM,SAAS,uBAAuB,CAAC,GAAG,CAAE,KAAK,CAAE,KAAK,CAAE,CACvD,IAAM,SAAS,CAAG,IAAI,CAAC,AAEvB,IAAI,QAAQ,UAAA,CACR,MAAM,UAAA,CACN,YAAY,UAAA,CACZ,SAAS,UAAA,CACT,KAAK,UAAA,CACL,WAAW,UAAA,CAAC,AAEhB,IAAM,QAAQ,CAAG,KAAK,CAAC,MAAM,CAAC,AAC9B,IAAM,YAAY,CAAG,SAAS,CAAC,MAAM,CAAC,AAEtC,GAAI,CAAC,GAAG,CAAE,CACN,OAAO,GAAG,CAAC,CACd;;;AAKD,MAAO,IAAI,EAAE;;AAIT,QAAQ,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,GAAG,KAAK,CAAC,CAAC,AACpC,GAAI,QAAQ,GAAG,CAAC,CAAE,CACd,OAAO,GAAG,CAAC,CACd;;AAID,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC,GAAG,CAAE,QAAQ,GAAG,QAAQ,CAAC,CAAC,AAC/C,GAAI,MAAM,GAAG,CAAC,CAAE,CACZ,OAAO,GAAG,CAAC,CACd;;AAID,YAAY,GAAG,GAAG,CAAC,OAAO,CAAC,SAAS,CAAE,QAAQ,GAAG,QAAQ,CAAC,CAAC,AAC3D,GAAI,YAAY,GAAG,QAAQ,IAAI,YAAY,GAAG,MAAM,CAAE,CAElD,SAAS,GAAG,GAAG,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,AACnC,KAAK,GAAG,QAAQ,CAAC,GAAG,CAAC,SAAS,CAAC,YAAY,GAAG,YAAY,CAAE,MAAM,GAAG,CAAC,CAAC,CAAE,EAAE,CAAC,CAAC;;AAI7E,OAAQ,SAAS;;AAGb,KAAK,GAAG,CAAC,AACT,KAAK,GAAG,CAAC,AACT,KAAK,GAAG,CACJ,WAAW,GAAG,eAAe,CAAC,KAAK,CAAC,QAAQ,EAAE,CAAE,KAAK,CAAC,CAAC,AACvD,MAAM,AACV,KAAK,GAAG,CACJ,WAAW,GAAG,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAE,KAAK,CAAC,CAAC,AACzD,MAAM,AACV,KAAK,GAAG,CACJ,WAAW,GAAG,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAE,KAAK,CAAC,CAAC,WAAW,EAAE,CAAC,AACvE,MAAM,AACV,KAAK,GAAG,CACJ,WAAW,GAAG,eAAe,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAE,KAAK,CAAC,CAAC,AACxD,MAAM,AACV;;AAGI,OAAO,GAAG,CAAC,CAClB,CACJ,KAAM,CACH,WAAW,GAAG,KAAK,CAAC,CACvB,AAED,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAE,QAAQ,CAAC,GAAG,WAAW,GAAG,GAAG,CAAC,SAAS,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAC9E,CACJ,AAEM,SAAS,oBAAoB,CAAC,iBAAiB,CAAE,SAAS,CAAE,cAAc,CAAE,KAAK,CAAE,CACtF,IAAI,GAAG,UAAA,CACH,QAAQ,UAAA,CACR,qBAAqB,UAAA,CACrB,mBAAmB,UAAA,CAAC,AAExB,QAAQ,GAAG,cAAc,CAAC,eAAe,CAAC;;;;OAO1C,GAAI,KAAK,CAAC,QAAQ,CAAC,CAAE,CACjB,QAAQ,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,QAAQ,CAAC,CACxD,AAED,qBAAqB,GAAG,UAAU,CAAC,CAAC,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,KAAK,GAAI,KAAK,GAAG,QAAQ,CAAC,CAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,AAC7G,mBAAmB,GAAG,UAAU,CAAC,CAAC,qBAAqB,GAAG,QAAQ,CAAA,CAAE,OAAO,CAAC,CAAC,CAAC,CAAC,CAAC,AAEhF,GAAG,GAAG,4BAAa,CAAC,AAEpB,GAAG,CAAC,cAAc,GAAG,cAAc,CAAC,AACpC,GAAG,CAAC,QAAQ,GAAG,QAAQ,CAAC,AACxB,GAAG,CAAC,qBAAqB,GAAG,qBAAqB,CAAC,AAElD,GAAG,CAAC,cAAc,GAAG,iBAAiB,CAAC,iCAAiC,CAAC,GAAG,CAAC,qBAAqB,CAAE,cAAc,CAAC,CAAC,AAEpH,GAAG,CAAC,qBAAqB,GAAG,iBAAiB,CAAC,6CAA6C,CAAC,GAAG,CAAC,qBAAqB,CAAE,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAE,SAAS,CAAC,CAAC,AACxK,GAAG,CAAC,mBAAmB,GAAG,iBAAiB,CAAC,2CAA2C,CAAC,mBAAmB,CAAE,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAE,SAAS,CAAC,CAAC;AAG9J,GAAG,CAAC,aAAa,GAAG,iBAAiB,CAAC,sBAAsB,CAAC,GAAG,CAAE,SAAS,CAAC,CAAC,AAE7E,GAAG,CAAC,iBAAiB,GAAG,mBAAmB,CAAC,GAAG,CAAE,KAAK,CAAC,CAAC,AACxD,GAAG,CAAC,eAAe,GAAG,KAAK,CAAC,AAE5B,OAAO,GAAG,CAAC,CACd,AAEM,SAAS,mBAAmB,CAAC,iBAAiB,CAAE,SAAS,CAAE,cAAc,CAAE,IAAI,CAAE,QAAQ,CAAE,UAAU,CAAE,GAAG,CAAE,KAAK,CAAE,KAAK,CAAE,SAAS,CAAE,CACxI,IAAM,UAAU,CAAG,IAAI,GAAG,UAAU,CAAC,AACrC,IAAM,cAAc,CAAG,IAAI,CAAC,GAAG,CAAC,QAAQ,GAAG,UAAU,CAAE,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,kBAAkB,CAAC,CAAC,AAEhH,IAAI,qBAAqB,UAAA,CACrB,mBAAmB,UAAA,CACnB,GAAG,UAAA,CAAC,AAER,qBAAqB,GAAG,iBAAiB,CAAC,iCAAiC,CAAC,UAAU,CAAE,cAAc,CAAC,CAAC,AACxG,mBAAmB,GAAG,qBAAqB,GAAG,cAAc,CAAC,AAE7D,GAAG,GAAG,4BAAa,CAAC,AAEpB,GAAG,CAAC,cAAc,GAAG,cAAc,CAAC,AACpC,GAAG,CAAC,QAAQ,GAAG,cAAc,CAAC,AAC9B,GAAG,CAAC,cAAc,GAAG,UAAU,CAAC,AAEhC,GAAG,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;AAGlD,GAAG,CAAC,qBAAqB,GAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,UAAU,CAAC,AACrF,GAAG,CAAC,mBAAmB,GAAG,iBAAiB,CAAC,2CAA2C,CAAC,mBAAmB,CAAE,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAE,SAAS,CAAC,CAAC;AAG9J,GAAG,CAAC,aAAa,GAAG,iBAAiB,CAAC,sBAAsB,CAAC,GAAG,CAAE,SAAS,CAAC,CAAC,AAE7E,GAAG,CAAC,eAAe,GAAG,SAAS,CAAG,SAAS,CAAG,IAAI,CAAC,AAEnD,GAAG,CAAC,iBAAiB,GAAG,mBAAmB,CAAC,GAAG,CAAE,KAAK,CAAC,CAAC,AAExD,GAAG,GAAG,uBAAuB,CAAC,GAAG,CAAE,QAAQ,CAAE,GAAG,CAAC,iBAAiB,CAAC,CAAC,AACpE,GAAG,GAAG,uBAAuB,CAAC,GAAG,CAAE,MAAM,CAAE,GAAG,CAAC,eAAe,CAAC,CAAC,AAChE,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC,AAChB,GAAG,CAAC,UAAU,GAAG,KAAK,CAAC,AACvB,GAAG,CAAC,eAAe,GAAG,KAAK,CAAC,AAE5B,OAAO,GAAG,CAAC,CACd,AAEM,SAAS,iBAAiB,CAAC,KAAK,CAAE,cAAc,CAAE,CACrD,GAAI,CAAC,cAAc,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAE,OAAO,IAAI,CAAC,AAE7D,IAAM,EAAE,CAAG,cAAc,CAAC,QAAQ,CAAC,MAAM,CAAC,AAC1C,IAAI,GAAG,UAAA,CACH,CAAC,UAAA,CAAC,AAEN,GAAI,KAAK,GAAG,EAAE,CAAE,CACZ,GAAG,GAAG,cAAc,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAC,AACrC,GAAI,GAAG,IAAI,GAAG,CAAC,eAAe,KAAK,KAAK,CAAE,CACtC,OAAO,GAAG,CAAC,CACd,CACJ,AAED,IAAK,CAAC,GAAG,CAAC,CAAE,CAAC,GAAG,EAAE,CAAE,CAAC,EAAE,EAAE,CACrB,GAAG,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,AAEjC,GAAI,GAAG,IAAI,GAAG,CAAC,eAAe,KAAK,KAAK,CAAE,CACtC,OAAO,GAAG,CAAC,CACd,CACJ,AAED,OAAO,IAAI,CAAC,CACf,AAEM,SAAS,iCAAiC,CAAC,iBAAiB,CAAE,SAAS,CAAE,cAAc,CAAE,aAAa,CAAE,KAAK,CAAE,2BAA2B,CAAE,CAC/I,IAAM,QAAQ,CAAG,cAAc,CAAC,eAAe,CAAC,AAChD,IAAM,aAAa,CAAG,cAAc,CAAC,UAAU,CAAC,MAAM,CAAC,GAAG,CAAC,QAAQ,CAAC,aAAa,CAAC,AAClF,IAAM,kBAAkB,CAAG,cAAc,CAAC,wBAAwB,CAAC,AACnE,IAAI,mBAAmB,CAAG,CACtB,KAAK,CAAE,iBAAiB,CAAC,yCAAyC,CAAC,cAAc,CAAE,kBAAkB,CAAC,KAAK,CAAC,CAC5G,GAAG,CAAE,iBAAiB,CAAC,yCAAyC,CAAC,cAAc,CAAE,kBAAkB,CAAC,GAAG,CAAC,CAC3G,CAAC,AACF,IAAM,kBAAkB,CAAG,cAAc,CAAC,QAAQ,CAAC,AACnD,IAAM,sBAAsB,CAAG,CAAC,GAAG,QAAQ,CAAC,AAC5C,IAAM,sBAAsB,CAAG,2BAA2B,IAAI,IAAI,CAAC,GAAG,CAAC,CAAC,GAAG,aAAa,CAAE,EAAE,GAAG,QAAQ,CAAC,CAAC,AAEzG,IAAI,sBAAsB,CAAG,GAAG,CAAC,AACjC,IAAI,aAAa,CAAG,IAAI,CAAC,AAEzB,IAAI,KAAK,UAAA,CACL,GAAG,UAAA,CACH,KAAK,UAAA,CAAC,AAEV,mBAAmB,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,CAAC,mBAAmB,CAAC,KAAK,CAAE,CAAC,CAAC,CAAC,AAEnE,GAAI,SAAS,IAAI,CAAC,iBAAiB,CAAC,mBAAmB,EAAE,CAAE,CACvD,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,KAAK,GAAG,QAAQ,CAAC,CAAC,AACzD,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,mBAAmB,CAAC,GAAG,GAAG,QAAQ,CAAC,CAAC,AACrD,KAAK,GAAG,CAAC,KAAK,CAAE,KAAK,CAAE,GAAG,CAAE,GAAG,CAAC,CAAC,AACjC,OAAO,KAAK,CAAC,CAChB;;AAID,GAAI,kBAAkB,IAAI,kBAAkB,CAAC,MAAM,GAAG,CAAC,CAAE,CACrD,aAAa,GAAG,iBAAiB,CAAC,KAAK,CAAE,cAAc,CAAC,CAAC,AACzD,GAAI,aAAa,CAAE,CACf,sBAAsB,GAAG,iBAAiB,CAAC,yCAAyC,CAAC,cAAc,CAAE,aAAa,CAAC,qBAAqB,CAAC,CAAC,CAC7I,KAAM,CACH,sBAAsB,GAAG,KAAK,GAAG,CAAC,CAAG,KAAK,GAAG,QAAQ,CACjD,iBAAiB,CAAC,yCAAyC,CAAC,cAAc,CAAE,aAAa,CAAC,CAAC,CAClG,CAEJ,KAAM;;;AAIH,sBAAsB,GAAG,KAAK,GAAG,CAAC,CAAG,KAAK,GAAG,QAAQ,CAAG,SAAS,CAAG,mBAAmB,CAAC,GAAG,CAAG,mBAAmB,CAAC,KAAK,CAAC,CAC3H;AAGD,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,sBAAsB,GAAG,sBAAsB,CAAE,mBAAmB,CAAC,KAAK,CAAC,GAAG,QAAQ,CAAC,CAAC,AACpH,GAAG,GAAG,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,GAAG,sBAAsB,GAAG,QAAQ,CAAE,mBAAmB,CAAC,GAAG,GAAG,QAAQ,CAAC,CAAC,CAAC,AAE1G,KAAK,GAAG,CAAC,KAAK,CAAE,KAAK,CAAE,GAAG,CAAE,GAAG,CAAC,CAAC,AAEjC,OAAO,KAAK,CAAC,CAChB","file":"SegmentsUtils.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\nimport Segment from './../vo/Segment';\n\nfunction zeroPadToLength(numStr, minStrLength) {\n    while (numStr.length < minStrLength) {\n        numStr = '0' + numStr;\n    }\n    return numStr;\n}\n\nfunction getNumberForSegment(segment, segmentIndex) {\n    return segment.representation.startNumber + segmentIndex;\n}\n\nexport function unescapeDollarsInTemplate(url) {\n    return url ? url.split('$$').join('$') : url;\n}\n\nexport function replaceIDForTemplate(url, value) {\n    if (!value || !url || url.indexOf('$RepresentationID$') === -1) { return url; }\n    let v = value.toString();\n    return url.split('$RepresentationID$').join(v);\n}\n\nexport function replaceTokenForTemplate(url, token, value) {\n    const formatTag = '%0';\n\n    let startPos,\n        endPos,\n        formatTagPos,\n        specifier,\n        width,\n        paddedValue;\n\n    const tokenLen = token.length;\n    const formatTagLen = formatTag.length;\n\n    if (!url) {\n        return url;\n    }\n\n    // keep looping round until all instances of <token> have been\n    // replaced. once that has happened, startPos below will be -1\n    // and the completed url will be returned.\n    while (true) {\n\n        // check if there is a valid $<token>...$ identifier\n        // if not, return the url as is.\n        startPos = url.indexOf('$' + token);\n        if (startPos < 0) {\n            return url;\n        }\n\n        // the next '$' must be the end of the identifier\n        // if there isn't one, return the url as is.\n        endPos = url.indexOf('$', startPos + tokenLen);\n        if (endPos < 0) {\n            return url;\n        }\n\n        // now see if there is an additional format tag suffixed to\n        // the identifier within the enclosing '$' characters\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\n        if (formatTagPos > startPos && formatTagPos < endPos) {\n\n            specifier = url.charAt(endPos - 1);\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\n\n            // support the minimum specifiers required by IEEE 1003.1\n            // (d, i , o, u, x, and X) for completeness\n            switch (specifier) {\n                // treat all int types as uint,\n                // hence deliberate fallthrough\n                case 'd':\n                case 'i':\n                case 'u':\n                    paddedValue = zeroPadToLength(value.toString(), width);\n                    break;\n                case 'x':\n                    paddedValue = zeroPadToLength(value.toString(16), width);\n                    break;\n                case 'X':\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\n                    break;\n                case 'o':\n                    paddedValue = zeroPadToLength(value.toString(8), width);\n                    break;\n                default:\n                    //TODO: commented out logging to supress jshint warning -- `log` is undefined here\n                    //log('Unsupported/invalid IEEE 1003.1 format identifier string in URL');\n                    return url;\n            }\n        } else {\n            paddedValue = value;\n        }\n\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\n    }\n}\n\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\n    let seg,\n        duration,\n        presentationStartTime,\n        presentationEndTime;\n\n    duration = representation.segmentDuration;\n\n    /*\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\n     * in the same way as for the last Media Segment in the Representation.\n     */\n    if (isNaN(duration)) {\n        duration = representation.adaptation.period.duration;\n    }\n\n    presentationStartTime = parseFloat((representation.adaptation.period.start + (index * duration)).toFixed(5));\n    presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\n\n    seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = duration;\n    seg.presentationStartTime = presentationStartTime;\n\n    seg.mediaStartTime = timelineConverter.calcMediaTimeFromPresentationTime(seg.presentationStartTime, representation);\n\n    seg.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(seg.presentationStartTime, representation.adaptation.period.mpd, isDynamic);\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n    seg.replacementNumber = getNumberForSegment(seg, index);\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\n    const scaledTime = time / fTimescale;\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\n\n    let presentationStartTime,\n        presentationEndTime,\n        seg;\n\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\n    presentationEndTime = presentationStartTime + scaledDuration;\n\n    seg = new Segment();\n\n    seg.representation = representation;\n    seg.duration = scaledDuration;\n    seg.mediaStartTime = scaledTime;\n\n    seg.presentationStartTime = presentationStartTime;\n\n    // For SegmentTimeline every segment is available at loadedTime\n    seg.availabilityStartTime = representation.adaptation.period.mpd.manifest.loadedTime;\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\n\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\n\n    seg.replacementTime = tManifest ? tManifest : time;\n\n    seg.replacementNumber = getNumberForSegment(seg, index);\n\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\n    seg.media = url;\n    seg.mediaRange = range;\n    seg.availabilityIdx = index;\n\n    return seg;\n}\n\nexport function getSegmentByIndex(index, representation) {\n    if (!representation || !representation.segments) return null;\n\n    const ln = representation.segments.length;\n    let seg,\n        i;\n\n    if (index < ln) {\n        seg = representation.segments[index];\n        if (seg && seg.availabilityIdx === index) {\n            return seg;\n        }\n    }\n\n    for (i = 0; i < ln; i++) {\n        seg = representation.segments[i];\n\n        if (seg && seg.availabilityIdx === index) {\n            return seg;\n        }\n    }\n\n    return null;\n}\n\nexport function decideSegmentListRangeForTemplate(timelineConverter, isDynamic, representation, requestedTime, index, givenAvailabilityUpperLimit) {\n    const duration = representation.segmentDuration;\n    const minBufferTime = representation.adaptation.period.mpd.manifest.minBufferTime;\n    const availabilityWindow = representation.segmentAvailabilityRange;\n    let periodRelativeRange = {\n        start: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow.start),\n        end: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow.end)\n    };\n    const currentSegmentList = representation.segments;\n    const availabilityLowerLimit = 2 * duration;\n    const availabilityUpperLimit = givenAvailabilityUpperLimit || Math.max(2 * minBufferTime, 10 * duration);\n\n    let originAvailabilityTime = NaN;\n    let originSegment = null;\n\n    let start,\n        end,\n        range;\n\n    periodRelativeRange.start = Math.max(periodRelativeRange.start, 0);\n\n    if (isDynamic && !timelineConverter.isTimeSyncCompleted()) {\n        start = Math.floor(periodRelativeRange.start / duration);\n        end = Math.floor(periodRelativeRange.end / duration);\n        range = {start: start, end: end};\n        return range;\n    }\n\n    // if segments exist we should try to find the latest buffered time, which is the presentation time of the\n    // segment for the current index\n    if (currentSegmentList && currentSegmentList.length > 0) {\n        originSegment = getSegmentByIndex(index, representation);\n        if (originSegment) {\n            originAvailabilityTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, originSegment.presentationStartTime);\n        } else {\n            originAvailabilityTime = index > 0 ? index * duration :\n                timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, requestedTime);\n        }\n\n    } else {\n        // If no segments exist, but index > 0, it means that we switch to the other representation, so\n        // we should proceed from this time.\n        // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds\n        originAvailabilityTime = index > 0 ? index * duration : isDynamic ? periodRelativeRange.end : periodRelativeRange.start;\n    }\n\n    // segment list should not be out of the availability window range\n    start = Math.floor(Math.max(originAvailabilityTime - availabilityLowerLimit, periodRelativeRange.start) / duration);\n    end = Math.floor(Math.min(start + availabilityUpperLimit / duration, periodRelativeRange.end / duration));\n\n    range = {start: start, end: end};\n\n    return range;\n}\n"]}