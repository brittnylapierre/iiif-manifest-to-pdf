{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":[],"mappings":"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","file":"TimelineConverter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\n\nfunction TimelineConverter() {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function initialize() {\n        resetInitialSettings();\n        eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n    }\n\n    function isTimeSyncCompleted() {\n        return isClientServerTimeSyncCompleted;\n    }\n\n    function setTimeSyncCompleted(value) {\n        isClientServerTimeSyncCompleted = value;\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function setClientTimeOffset(value) {\n        clientServerTimeShift = value;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        let availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        let suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        const range = { start: voPeriod.start, end: voPeriod.start + voPeriod.duration };\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n        const periodEnd = voPeriod.start + voPeriod.duration;\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\n        range.end = now >= periodEnd && now - d < periodEnd ? periodEnd - d : now - d;\n\n        return range;\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    /*\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n    * FYI StreamController's onManifestUpdated entry point to timeSync\n    * */\n    function onTimeSyncComplete(e) {\n\n        if (isClientServerTimeSyncCompleted) return;\n\n        if (e.offset !== undefined) {\n\n            setClientTimeOffset(e.offset / 1000);\n            isClientServerTimeSyncCompleted = true;\n\n        }\n    }\n\n    function calcMSETimeOffset(representation) {\n        // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n        const presentationOffset = representation.presentationTimeOffset;\n        const periodStart = representation.adaptation.period.start;\n        return (periodStart - presentationOffset);\n    }\n\n    function resetInitialSettings() {\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    function reset() {\n        eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        isTimeSyncCompleted: isTimeSyncCompleted,\n        setTimeSyncCompleted: setTimeSyncCompleted,\n        getClientTimeOffset: getClientTimeOffset,\n        setClientTimeOffset: setClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        calcMSETimeOffset: calcMSETimeOffset,\n        reset: reset\n    };\n\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);"]}