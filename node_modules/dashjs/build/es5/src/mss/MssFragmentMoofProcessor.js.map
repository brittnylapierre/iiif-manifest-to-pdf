{"version":3,"sources":["../../../../src/mss/MssFragmentMoofProcessor.js"],"names":[],"mappings":"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","file":"MssFragmentMoofProcessor.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n/**\n * @module MssFragmentMoovProcessor\n * @param {Object} config object\n */\nfunction MssFragmentMoofProcessor(config) {\n\n    config = config || {};\n    let instance;\n    let metricsModel = config.metricsModel;\n    let playbackController = config.playbackController;\n    const ISOBoxer = config.ISOBoxer;\n    const log = config.log;\n\n    function setup() {\n    }\n\n    function processTfrf(request, tfrf, tfdt, streamProcessor) {\n        let representationController = streamProcessor.getRepresentationController();\n        let representation = representationController.getCurrentRepresentation();\n        let indexHandler = streamProcessor.getIndexHandler();\n\n        let manifest = representation.adaptation.period.mpd.manifest;\n        let adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\n\n        // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case)\n        let segments = adaptation.SegmentTemplate.SegmentTimeline.S;\n        let entries = tfrf.entry;\n        let entry,\n            segmentTime;\n        let segment = null;\n        let type = adaptation.contentType;\n        let t = 0;\n        let availabilityStartTime = null;\n        let range;\n\n        if (manifest.type !== 'dynamic') {\n            return;\n        }\n\n        if (entries.length === 0) {\n            return;\n        }\n\n        // Consider only first tfrf entry (to avoid pre-condition failure on fragment info requests)\n        entry = entries[0];\n\n        // Get last segment time\n        segmentTime = segments[segments.length - 1].tManifest ? parseFloat(segments[segments.length - 1].tManifest) : segments[segments.length - 1].t;\n\n        // Check if we have to append new segment to timeline\n        if (entry.fragment_absolute_time <= segmentTime) {\n\n            // Update DVR window range\n            // => set range end to end time of current segment\n            range = {\n                start: segments[0].t / adaptation.SegmentTemplate.timescale,\n                end: (tfdt.baseMediaDecodeTime / adaptation.SegmentTemplate.timescale) + request.duration\n            };\n\n            updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo);\n            return;\n        }\n\n        log('[MssFragmentMoofProcessor][', type,'] Add new segment - t = ', (entry.fragment_absolute_time /  10000000.0));\n        segment = {};\n        segment.t = entry.fragment_absolute_time;\n        segment.d = entry.fragment_duration;\n        segments.push(segment);\n\n        //\n        if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {\n            // Get timestamp of the last segment\n            segment = segments[segments.length - 1];\n            t = segment.t;\n\n            // Determine the segments' availability start time\n            availabilityStartTime = t - (manifest.timeShiftBufferDepth * 10000000);\n\n            // Remove segments prior to availability start time\n            segment = segments[0];\n            while (segment.t < availabilityStartTime) {\n                log('[MssFragmentMoofProcessor]Remove segment  - t = ' + (segment.t / 10000000.0));\n                segments.splice(0, 1);\n                segment = segments[0];\n            }\n\n            // Update DVR window range\n            // => set range end to end time of current segment\n            range = {\n                start: segments[0].t / adaptation.SegmentTemplate.timescale,\n                end: (tfdt.baseMediaDecodeTime / adaptation.SegmentTemplate.timescale) + request.duration\n            };\n\n            updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo);\n        }\n\n        indexHandler.updateSegmentList(representation);\n    }\n\n    function updateDVR(type, range, manifestInfo) {\n        let dvrInfos = metricsModel.getMetricsFor(type).DVRInfo;\n        if (dvrInfos) {\n            if (dvrInfos.length === 0 || (dvrInfos.length > 0 && range.end > dvrInfos[dvrInfos.length - 1].range.end)) {\n                log('[MssFragmentMoofProcessor][', type, '] Update DVR Infos [' + range.start + ' - ' + range.end + ']');\n                metricsModel.addDVRInfo(type, playbackController.getTime(), manifestInfo, range);\n            }\n        }\n    }\n\n    // This function returns the offset of the 1st byte of a child box within a container box\n    function getBoxOffset(parent, type) {\n        let offset = 8;\n        let i = 0;\n\n        for (i = 0; i < parent.boxes.length; i++) {\n            if (parent.boxes[i].type === type) {\n                return offset;\n            }\n            offset += parent.boxes[i].size;\n        }\n        return offset;\n    }\n\n    function convertFragment(e, sp) {\n\n        let i;\n\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        if (!e.response) {\n            return;\n        }\n        let isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        let tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        let traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        let trun = isoFile.fetch('trun');\n\n        // Process tfxd boxes\n        // This box provide absolute timestamp but we take the segment start time for tfdt\n        let tfxd = isoFile.fetch('tfxd');\n        if (tfxd) {\n            tfxd._parent.boxes.splice(tfxd._parent.boxes.indexOf(tfxd), 1);\n            tfxd = null;\n        }\n        let tfrf = isoFile.fetch('tfrf');\n        if (tfrf) {\n            processTfrf(e.request, tfrf, tfdt, sp);\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n\n        // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)\n        // => convert sepiff box it into a senc box\n        // => create saio and saiz boxes (if not already present)\n        let sepiff = isoFile.fetch('sepiff');\n        if (sepiff !== null) {\n            sepiff.type = 'senc';\n            sepiff.usertype = undefined;\n\n            let saio = isoFile.fetch('saio');\n            if (saio === null) {\n                // Create Sample Auxiliary Information Offsets Box box (saio)\n                saio = ISOBoxer.createFullBox('saio', traf);\n                saio.version = 0;\n                saio.flags = 0;\n                saio.entry_count = 1;\n                saio.offset = [0];\n\n                let saiz = ISOBoxer.createFullBox('saiz', traf);\n                saiz.version = 0;\n                saiz.flags = 0;\n                saiz.sample_count = sepiff.sample_count;\n                saiz.default_sample_info_size = 0;\n                saiz.sample_info_size = [];\n\n                if (sepiff.flags & 0x02) {\n                    // Sub-sample encryption => set sample_info_size for each sample\n                    for (i = 0; i < sepiff.sample_count; i += 1) {\n                        // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)\n                        // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)\n                        saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);\n                    }\n                } else {\n                    // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)\n                    saiz.default_sample_info_size = 8;\n                }\n            }\n        }\n\n        tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false\n        tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true\n        trun.flags |= 0x000001; // set trun.data-offset-present to true\n\n        // Update trun.data_offset field that corresponds to first data byte (inside mdat box)\n        let moof = isoFile.fetch('moof');\n        let length = moof.getLength();\n        trun.data_offset = length + 8;\n\n        // Update saio box offset field according to new senc box offset\n        let saio = isoFile.fetch('saio');\n        if (saio !== null) {\n            let trafPosInMoof = getBoxOffset(moof, 'traf');\n            let sencPosInTraf = getBoxOffset(traf, 'senc');\n            // Set offset from begin fragment to the first IV field in senc box\n            saio.offset[0] = trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)\n        }\n\n        // Write transformed/processed fragment into request reponse data\n        e.response = isoFile.write();\n    }\n\n    function updateSegmentList(e, sp) {\n\n        // e.request contains request description object\n        // e.response contains fragment bytes\n        if (!e.response) {\n            return;\n        }\n\n        let isoFile = ISOBoxer.parseBuffer(e.response);\n        // Update track_Id in tfhd box\n        let tfhd = isoFile.fetch('tfhd');\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\n\n        // Add tfdt box\n        let tfdt = isoFile.fetch('tfdt');\n        let traf = isoFile.fetch('traf');\n        if (tfdt === null) {\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\n            tfdt.version = 1;\n            tfdt.flags = 0;\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\n        }\n\n        let tfrf = isoFile.fetch('tfrf');\n        if (tfrf) {\n            processTfrf(e.request, tfrf, tfdt, sp);\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\n            tfrf = null;\n        }\n    }\n\n    instance = {\n        convertFragment: convertFragment,\n        updateSegmentList: updateSegmentList\n    };\n\n    setup();\n    return instance;\n}\n\nMssFragmentMoofProcessor.__dashjs_factory_name = 'MssFragmentMoofProcessor';\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentMoofProcessor); /* jshint ignore:line */\n"]}