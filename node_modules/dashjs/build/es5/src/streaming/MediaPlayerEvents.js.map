{"version":3,"sources":["../../../../src/streaming/MediaPlayerEvents.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;o3CA8BuB,2BAA2B;;;OAK5C,iBAAiB,kCAAjB,iBAAiB;;OAKR,SALT,iBAAiB,EAKL,sBALZ,iBAAiB,EAMf,2BANF,iBAAiB,2CAMP;;;;WAMR,IAAI,CAAC,aAAa,GAAG,aAAa,CAAC;;;;WAMnC,IAAI,CAAC,YAAY,GAAG,eAAe,CAAC;;;;WAMpC,IAAI,CAAC,aAAa,GAAG,cAAc,CAAC;;;WAMpC,IAAI,CAAC,0BAA0B,GAAG,oBAAoB,CAAC;;;WAMvD,IAAI,CAAC,KAAK,GAAG,OAAO,CAAC;;;WAMrB,IAAI,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;;;WAK7D,IAAI,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;;;WAKzD,IAAI,CAAC,0BAA0B,GAAG,0BAA0B,CAAC;;;WAK7D,IAAI,CAAC,GAAG,GAAG,KAAK,CAAC;;;;WAMjB,IAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;;;WAKxC,IAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;;;WAKxC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC;;;WAKtC,IAAI,CAAC,YAAY,GAAG,aAAa,CAAC;;;WAKlC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC;;;WAKtC,IAAI,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;;;WAKvD,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;;;WAMnD,IAAI,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;;;WAMzD,IAAI,CAAC,uBAAuB,GAAG,uBAAuB,CAAC;;;WAMvD,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;;;WAMnD,IAAI,CAAC,kBAAkB,GAAG,mBAAmB,CAAC;;;WAM9C,IAAI,CAAC,kBAAkB,GAAG,mBAAmB,CAAC;;;WAM9C,IAAI,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;;;WAMzD,IAAI,CAAC,iBAAiB,GAAG,oBAAoB,CAAC;;;WAK9C,IAAI,CAAC,gBAAgB,GAAG,gBAAgB,CAAC;;;WAMzC,IAAI,CAAC,WAAW,GAAG,YAAY,CAAC;;;;;WAQhC,IAAI,CAAC,QAAQ,GAAG,SAAS,CAAC;;;WAM1B,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC;;;;WAOtC,IAAI,CAAC,cAAc,GAAG,eAAe,CAAC;;;WAKtC,IAAI,CAAC,oBAAoB,GAAG,oBAAoB,CAAC;;;;WAMjD,IAAI,CAAC,wBAAwB,GAAG,wBAAwB,CAAC;;;WAKzD,IAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;;;;;WAOxC,IAAI,CAAC,gBAAgB,GAAG,iBAAiB,CAAC;;;;;WAO1C,IAAI,CAAC,iBAAiB,GAAG,kBAAkB,CAAC;;;WAK5C,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;;;WAKnD,IAAI,CAAC,eAAe,GAAG,gBAAgB,CAAC;;;WAKxC,IAAI,CAAC,gBAAgB,GAAG,iBAAiB,CAAC;;;WAM1C,IAAI,CAAC,mBAAmB,GAAG,mBAAmB,CAAC;;;;;WAQ/C,IAAI,CAAC,gBAAgB,GAAG,iBAAiB,CAAC;;;WAK1C,IAAI,CAAC,qBAAqB,GAAG,qBAAqB,CAAC;;;WAKnD,IAAI,CAAC,yBAAyB,GAAG,yBAAyB,CAAC,CAC9D,OA7OC,iBAAiB,uCAgPvB,IAAI,iBAAiB,CAAG,IAAI,iBAAiB,EAAE,CAAC,qBACjC,iBAAiB","file":"MediaPlayerEvents.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventsBase from '../core/events/EventsBase';\n/**\n * @class\n *\n */\nclass MediaPlayerEvents extends EventsBase {\n\n    /**\n     * @description Public facing external events to be used when developing a player that implements dash.js.\n     */\n    constructor() {\n        super();\n        /**\n         * Triggered when playback will not start yet\n         * as the MPD's availabilityStartTime is in the future.\n         * Check delay property in payload to determine time before playback will start.\n         */\n        this.AST_IN_FUTURE = 'astInFuture';\n        /**\n         * Triggered when the video element's buffer state changes to stalled.\n         * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n         * @event MediaPlayerEvents#BUFFER_EMPTY\n         */\n        this.BUFFER_EMPTY = 'bufferStalled';\n        /**\n         * Triggered when the video element's buffer state changes to loaded.\n         * Check mediaType in payload to determine type (Video, Audio, FragmentedText).\n         * @event MediaPlayerEvents#BUFFER_LOADED\n         */\n        this.BUFFER_LOADED = 'bufferLoaded';\n\n        /**\n         * Triggered when the video element's buffer state changes, either stalled or loaded. Check payload for state.\n         * @event MediaPlayerEvents#BUFFER_LEVEL_STATE_CHANGED\n         */\n        this.BUFFER_LEVEL_STATE_CHANGED = 'bufferStateChanged';\n\n        /**\n         * Triggered when there is an error from the element or MSE source buffer.\n         * @event MediaPlayerEvents#ERROR\n         */\n        this.ERROR = 'error';\n\n        /**\n         * Triggered when a fragment download has completed.\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_COMPLETED\n         */\n        this.FRAGMENT_LOADING_COMPLETED = 'fragmentLoadingCompleted';\n        /**\n         * Triggered when a fragment download has started.\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_STARTED\n         */\n        this.FRAGMENT_LOADING_STARTED = 'fragmentLoadingStarted';\n        /**\n         * Triggered when a fragment download is abandoned due to detection of slow download base on the ABR abandon rule..\n         * @event MediaPlayerEvents#FRAGMENT_LOADING_ABANDONED\n         */\n        this.FRAGMENT_LOADING_ABANDONED = 'fragmentLoadingAbandoned';\n        /**\n         * Triggered when {@link module:Debug} log method is called.\n         * @event MediaPlayerEvents#LOG\n         */\n        this.LOG = 'log';\n        //TODO refactor with internal event\n        /**\n         * Triggered when the manifest load is complete\n         * @event MediaPlayerEvents#MANIFEST_LOADED\n         */\n        this.MANIFEST_LOADED = 'manifestLoaded';\n        /**\n         * Triggered anytime there is a change to the overall metrics.\n         * @event MediaPlayerEvents#METRICS_CHANGED\n         */\n        this.METRICS_CHANGED = 'metricsChanged';\n        /**\n         * Triggered when an individual metric is added, updated or cleared.\n         * @event MediaPlayerEvents#METRIC_CHANGED\n         */\n        this.METRIC_CHANGED = 'metricChanged';\n        /**\n         * Triggered every time a new metric is added.\n         * @event MediaPlayerEvents#METRIC_ADDED\n         */\n        this.METRIC_ADDED = 'metricAdded';\n        /**\n         * Triggered every time a metric is updated.\n         * @event MediaPlayerEvents#METRIC_UPDATED\n         */\n        this.METRIC_UPDATED = 'metricUpdated';\n        /**\n         * Triggered at the stream end of a period.\n         * @event MediaPlayerEvents#PERIOD_SWITCH_COMPLETED\n         */\n        this.PERIOD_SWITCH_COMPLETED = 'periodSwitchCompleted';\n        /**\n         * Triggered when a new period starts.\n         * @event MediaPlayerEvents#PERIOD_SWITCH_STARTED\n         */\n        this.PERIOD_SWITCH_STARTED = 'periodSwitchStarted';\n\n        /**\n         * Triggered when an ABR up /down switch is initiated; either by user in manual mode or auto mode via ABR rules.\n         * @event MediaPlayerEvents#QUALITY_CHANGE_REQUESTED\n         */\n        this.QUALITY_CHANGE_REQUESTED = 'qualityChangeRequested';\n\n        /**\n         * Triggered when the new ABR quality is being rendered on-screen.\n         * @event MediaPlayerEvents#QUALITY_CHANGE_RENDERED\n         */\n        this.QUALITY_CHANGE_RENDERED = 'qualityChangeRendered';\n\n        /**\n         * Triggered when the new track is being rendered.\n         * @event MediaPlayerEvents#TRACK_CHANGE_RENDERED\n         */\n        this.TRACK_CHANGE_RENDERED = 'trackChangeRendered';\n\n        /**\n         * Triggered when the source is setup and ready.\n         * @event MediaPlayerEvents#SOURCE_INITIALIZED\n         */\n        this.SOURCE_INITIALIZED = 'sourceInitialized';\n\n        /**\n         * Triggered when a stream (period) is loaded\n         * @event MediaPlayerEvents#STREAM_INITIALIZED\n         */\n        this.STREAM_INITIALIZED = 'streamInitialized';\n\n        /**\n         * Triggered when the player has been reset.\n         * @event MediaPlayerEvents#STREAM_TEARDOWN_COMPLETE\n         */\n        this.STREAM_TEARDOWN_COMPLETE = 'streamTeardownComplete';\n\n        /**\n         * Triggered once all text tracks detected in the MPD are added to the video element.\n         * @event MediaPlayerEvents#TEXT_TRACKS_ADDED\n         */\n        this.TEXT_TRACKS_ADDED = 'allTextTracksAdded';\n        /**\n         * Triggered when a text track is added to the video element's TextTrackList\n         * @event MediaPlayerEvents#TEXT_TRACK_ADDED\n         */\n        this.TEXT_TRACK_ADDED = 'textTrackAdded';\n\n        /**\n         * Triggered when a ttml chunk is parsed.\n         * @event MediaPlayerEvents#TTML_PARSED\n         */\n        this.TTML_PARSED = 'ttmlParsed';\n\n        /**\n         * Sent when enough data is available that the media can be played,\n         * at least for a couple of frames.  This corresponds to the\n         * HAVE_ENOUGH_DATA readyState.\n         * @event MediaPlayerEvents#CAN_PLAY\n         */\n        this.CAN_PLAY = 'canPlay';\n\n        /**\n         * Sent when playback completes.\n         * @event MediaPlayerEvents#PLAYBACK_ENDED\n         */\n        this.PLAYBACK_ENDED = 'playbackEnded';\n\n        /**\n         * Sent when an error occurs.  The element's error\n         * attribute contains more information.\n         * @event MediaPlayerEvents#PLAYBACK_ERROR\n         */\n        this.PLAYBACK_ERROR = 'playbackError';\n        /**\n         * Sent when playback is not allowed (for example if user gesture is needed).\n         * @event MediaPlayerEvents#PLAYBACK_NOT_ALLOWED\n         */\n        this.PLAYBACK_NOT_ALLOWED = 'playbackNotAllowed';\n        /**\n         * The media's metadata has finished loading; all attributes now\n         * contain as much useful information as they're going to.\n         * @event MediaPlayerEvents#PLAYBACK_METADATA_LOADED\n         */\n        this.PLAYBACK_METADATA_LOADED = 'playbackMetaDataLoaded';\n        /**\n         * Sent when playback is paused.\n         * @event MediaPlayerEvents#PLAYBACK_PAUSED\n         */\n        this.PLAYBACK_PAUSED = 'playbackPaused';\n        /**\n         * Sent when the media begins to play (either for the first time, after having been paused,\n         * or after ending and then restarting).\n         *\n         * @event MediaPlayerEvents#PLAYBACK_PLAYING\n         */\n        this.PLAYBACK_PLAYING = 'playbackPlaying';\n        /**\n         * Sent periodically to inform interested parties of progress downloading\n         * the media. Information about the current amount of the media that has\n         * been downloaded is available in the media element's buffered attribute.\n         * @event MediaPlayerEvents#PLAYBACK_PROGRESS\n         */\n        this.PLAYBACK_PROGRESS = 'playbackProgress';\n        /**\n         * Sent when the playback speed changes.\n         * @event MediaPlayerEvents#PLAYBACK_RATE_CHANGED\n         */\n        this.PLAYBACK_RATE_CHANGED = 'playbackRateChanged';\n        /**\n         * Sent when a seek operation completes.\n         * @event MediaPlayerEvents#PLAYBACK_SEEKED\n         */\n        this.PLAYBACK_SEEKED = 'playbackSeeked';\n        /**\n         * Sent when a seek operation begins.\n         * @event MediaPlayerEvents#PLAYBACK_SEEKING\n         */\n        this.PLAYBACK_SEEKING = 'playbackSeeking';\n\n        /**\n         * Sent when a seek operation has been asked.\n         * @event MediaPlayerEvents#PLAYBACK_SEEK_ASKED\n         */\n        this.PLAYBACK_SEEK_ASKED = 'playbackSeekAsked';\n\n        /**\n         * Sent when playback of the media starts after having been paused;\n         * that is, when playback is resumed after a prior pause event.\n         *\n         * @event MediaPlayerEvents#PLAYBACK_STARTED\n         */\n        this.PLAYBACK_STARTED = 'playbackStarted';\n        /**\n         * The time indicated by the element's currentTime attribute has changed.\n         * @event MediaPlayerEvents#PLAYBACK_TIME_UPDATED\n         */\n        this.PLAYBACK_TIME_UPDATED = 'playbackTimeUpdated';\n        /**\n         * Manifest validity changed - As a result of an MPD validity expiration event.\n         * @event MediaPlayerEvents#MANIFEST_VALIDITY_CHANGED\n         */\n        this.MANIFEST_VALIDITY_CHANGED = 'manifestValidityChanged';\n    }\n}\n\nlet mediaPlayerEvents = new MediaPlayerEvents();\nexport default mediaPlayerEvents;\n"]}