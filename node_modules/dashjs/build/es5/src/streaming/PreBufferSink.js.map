{"version":3,"sources":["../../../../src/streaming/PreBufferSink.js"],"names":[],"mappings":"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","file":"PreBufferSink.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport FactoryMaker from '../core/FactoryMaker';\n\n/**\n * This is a sink that is used to temporarily hold onto media chunks before a video element is added.\n * The discharge() function is used to get the chunks out of the PreBuffer for adding to a real SourceBuffer.\n *\n * @class PreBufferSink\n * @implements FragmentSink\n */\nfunction PreBufferSink(onAppendedCallback) {\n    const context = this.context;\n    const log = Debug(context).getInstance().log;\n\n    let chunks = [];\n    let outstandingInit;\n    let onAppended = onAppendedCallback;\n\n    function reset() {\n        chunks = [];\n        outstandingInit = null;\n        onAppended = null;\n    }\n\n    function append(chunk) {\n        if (chunk.segmentType !== 'InitializationSegment') { //Init segments are stored in the initCache.\n            chunks.push(chunk);\n            chunks.sort(function (a, b) { return a.start - b.start; });\n            outstandingInit = null;\n        } else {//We need to hold an init chunk for when a corresponding media segment is being downloaded when the discharge happens.\n            outstandingInit = chunk;\n        }\n\n        log('PreBufferSink appended chunk s: ' + chunk.start + '; e: ' + chunk.end);\n        if (onAppended) {\n            onAppended({\n                chunk: chunk\n            });\n        }\n    }\n\n    function remove(start, end) {\n        chunks = chunks.filter( a => !((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start))); //The opposite of the getChunks predicate.\n    }\n\n    //Nothing async, nothing to abort.\n    function abort() {\n    }\n\n    function getAllBufferRanges() {\n        let ranges = [];\n\n        for (let i = 0; i < chunks.length; i++) {\n            let chunk = chunks[i];\n            if (ranges.length === 0 || chunk.start > ranges[ranges.length - 1].end) {\n                ranges.push({ start: chunk.start, end: chunk.end });\n            } else {\n                ranges[ranges.length - 1].end = chunk.end;\n            }\n        }\n\n        //Implements TimeRanges interface. So acts just like sourceBuffer.buffered.\n        const timeranges = {\n            start: function (n) {\n                return ranges[n].start;\n            },\n            end: function (n) {\n                return ranges[n].end;\n            }\n        };\n\n        Object.defineProperty(timeranges, 'length', {\n            get: function () {\n                return ranges.length;\n            }\n        });\n\n        return timeranges;\n    }\n\n    /**\n     * Return the all chunks in the buffer the lie between times start and end.\n     * Because a chunk cannot be split, this returns the full chunk if any part of its time lies in the requested range.\n     * Chunks are removed from the buffer when they are discharged.\n     * @function PreBufferSink#discharge\n     * @param {?Number} start The start time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @param {?Number} end The end time from which to discharge from the buffer. If NaN, it is regarded as unbounded.\n     * @returns {Array} The set of chunks from the buffer within the time ranges.\n     */\n    function discharge(start, end) {\n        const result = getChunksAt(start, end);\n        if (outstandingInit) {\n            result.push(outstandingInit);\n            outstandingInit = null;\n        }\n\n        remove(start, end);\n\n        return result;\n    }\n\n    function getChunksAt(start, end) {\n        return chunks.filter( a => ((isNaN(end) || a.start < end) && (isNaN(start) || a.end > start)) );\n    }\n\n    const instance = {\n        getAllBufferRanges: getAllBufferRanges,\n        append: append,\n        remove: remove,\n        abort: abort,\n        discharge: discharge,\n        reset: reset\n    };\n\n    return instance;\n}\n\nPreBufferSink.__dashjs_factory_name = 'PreBufferSink';\nconst factory = FactoryMaker.getClassFactory(PreBufferSink);\nexport default factory;\n"]}