{"version":3,"sources":["../../../../src/streaming/SourceBufferSink.js"],"names":[],"mappings":"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","file":"SourceBufferSink.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Debug from '../core/Debug';\nimport DashJSError from './vo/DashJSError';\nimport EventBus from '../core/EventBus';\nimport Events from '../core/events/Events';\nimport FactoryMaker from '../core/FactoryMaker';\nimport TextController from './text/TextController';\n/**\n * @class SourceBufferSink\n * @implements FragmentSink\n */\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback) {\n    const context = this.context;\n    const log = Debug(context).getInstance().log;\n    const eventBus = EventBus(context).getInstance();\n\n    let buffer,\n        isAppendingInProgress;\n\n    let appendQueue = [];\n    let onAppended = onAppendedCallback;\n\n    function setup() {\n        isAppendingInProgress = false;\n\n        const codec = mediaInfo.codec;\n        try {\n            // Safari claims to support anything starting 'application/mp4'.\n            // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\n            // - currently no browser does, so check for it and use our own\n            // implementation. The same is true for codecs=\"wvtt\".\n            if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\n                throw new Error('not really supported');\n            }\n\n            buffer = mediaSource.addSourceBuffer(codec);\n        } catch (ex) {\n            // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\n            if ((mediaInfo.isText) || (codec.indexOf('codecs=\"stpp') !== -1) || (codec.indexOf('codecs=\"wvtt') !== -1)) {\n                const textController = TextController(context).getInstance();\n                buffer = textController.getTextSourceBuffer();\n            } else {\n                throw ex;\n            }\n        }\n    }\n\n    function reset() {\n        if (buffer) {\n            try {\n                mediaSource.removeSourceBuffer(buffer);\n            } catch (e) {\n                log('Failed to remove source buffer from media source.');\n            }\n            isAppendingInProgress = false;\n            buffer = null;\n        }\n        appendQueue = [];\n        onAppended = null;\n    }\n\n    function getBuffer() {\n        return buffer;\n    }\n\n    function getAllBufferRanges() {\n        return buffer.buffered;\n    }\n\n    function append(chunk) {\n        appendQueue.push(chunk);\n        if (!isAppendingInProgress) {\n            waitForUpdateEnd(buffer, appendNextInQueue.bind(this));\n        }\n    }\n\n    function remove(start, end, forceRemoval) {\n        const sourceBufferSink = this;\n        // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\n        waitForUpdateEnd(buffer, function () {\n            try {\n                if ((start >= 0) && (end > start) && (forceRemoval || mediaSource.readyState !== 'ended')) {\n                    buffer.remove(start, end);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(buffer, function () {\n                    eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                        buffer: sourceBufferSink,\n                        from: start,\n                        to: end\n                    });\n                });\n            } catch (err) {\n                eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\n                    buffer: sourceBufferSink,\n                    from: start,\n                    to: end,\n                    error: new DashJSError(err.code, err.message, null)\n                });\n            }\n        });\n    }\n\n    function appendNextInQueue() {\n        if (appendQueue.length > 0) {\n            isAppendingInProgress = true;\n            const nextChunk = appendQueue[0];\n            appendQueue.splice(0,1);\n\n            const afterSuccess = function () {\n                if (appendQueue.length > 0) {\n                    appendNextInQueue.call(this);\n                } else {\n                    isAppendingInProgress = false;\n                    if (onAppended) {\n                        onAppended({\n                            chunk: nextChunk\n                        });\n                    }\n                }\n            };\n\n            try {\n                if (buffer.appendBuffer) {\n                    buffer.appendBuffer(nextChunk.bytes);\n                } else {\n                    buffer.append(nextChunk.bytes, nextChunk);\n                }\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\n                waitForUpdateEnd(buffer, afterSuccess.bind(this));\n            } catch (err) {\n                log('SourceBuffer append failed \"' + err + '\"');\n                if (appendQueue.length > 0) {\n                    appendNextInQueue();\n                } else {\n                    isAppendingInProgress = false;\n                }\n\n                if (onAppended) {\n                    onAppended({\n                        chunk: nextChunk,\n                        error: new DashJSError(err.code, err.message, null)\n                    });\n                }\n            }\n        }\n    }\n\n    function abort() {\n        try {\n            if (mediaSource.readyState === 'open') {\n                buffer.abort();\n            } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\n                buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\n            }\n        } catch (ex) {\n            log('SourceBuffer append abort failed: \"' + ex + '\"');\n        }\n\n        appendQueue = [];\n    }\n\n    function waitForUpdateEnd(buffer, callback) {\n        let intervalId;\n        const CHECK_INTERVAL = 50;\n\n        const checkIsUpdateEnded = function () {\n            // if updating is still in progress do nothing and wait for the next check again.\n            if (buffer.updating) return;\n            // updating is completed, now we can stop checking and resolve the promise\n            clearInterval(intervalId);\n            callback();\n        };\n\n        const updateEndHandler = function () {\n            if (buffer.updating) return;\n\n            buffer.removeEventListener('updateend', updateEndHandler, false);\n            callback();\n        };\n\n        if (!buffer.updating) {\n            callback();\n            return;\n        }\n\n        // use updateend event if possible\n        if (typeof buffer.addEventListener === 'function') {\n            try {\n                buffer.addEventListener('updateend', updateEndHandler, false);\n            } catch (err) {\n                // use setInterval to periodically check if updating has been completed\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n            }\n        } else {\n            // use setInterval to periodically check if updating has been completed\n            intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\n        }\n    }\n\n    const instance = {\n        getAllBufferRanges: getAllBufferRanges,\n        getBuffer: getBuffer,\n        append: append,\n        remove: remove,\n        abort: abort,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\nconst factory = FactoryMaker.getClassFactory(SourceBufferSink);\nexport default factory;\n"]}