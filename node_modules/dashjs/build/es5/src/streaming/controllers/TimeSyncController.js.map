{"version":3,"sources":["../../../../../src/streaming/controllers/TimeSyncController.js"],"names":[],"mappings":"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","file":"TimeSyncController.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport Constants from '../constants/Constants';\nimport DashJSError from './../vo/DashJSError';\nimport {HTTPRequest} from './../vo/metrics/HTTPRequest';\nimport EventBus from './../../core/EventBus';\nimport Events from './../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport Debug from '../../core/Debug';\nimport URLUtils from '../utils/URLUtils';\n\nconst TIME_SYNC_FAILED_ERROR_CODE = 1;\nconst HTTP_TIMEOUT_MS = 5000;\n\nfunction TimeSyncController() {\n\n    let context = this.context;\n    let log = Debug(context).getInstance().log;\n    let eventBus = EventBus(context).getInstance();\n\n    const urlUtils = URLUtils(context).getInstance();\n\n    let instance,\n        offsetToDeviceTimeMs,\n        isSynchronizing,\n        isInitialised,\n        useManifestDateHeaderTimeSource,\n        handlers,\n        metricsModel,\n        dashMetrics,\n        baseURLController;\n\n    function initialize(timingSources, useManifestDateHeader) {\n        useManifestDateHeaderTimeSource = useManifestDateHeader;\n        offsetToDeviceTimeMs = 0;\n        isSynchronizing = false;\n        isInitialised = false;\n\n        // a list of known schemeIdUris and a method to call with @value\n        handlers = {\n            'urn:mpeg:dash:utc:http-head:2014':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2014':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2014':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2014':        directHandler,\n\n            // some specs referencing early ISO23009-1 drafts incorrectly use\n            // 2012 in the URI, rather than 2014. support these for now.\n            'urn:mpeg:dash:utc:http-head:2012':     httpHeadHandler,\n            'urn:mpeg:dash:utc:http-xsdate:2012':   httpHandler.bind(null, xsdatetimeDecoder),\n            'urn:mpeg:dash:utc:http-iso:2012':      httpHandler.bind(null, iso8601Decoder),\n            'urn:mpeg:dash:utc:direct:2012':        directHandler,\n\n            // it isn't clear how the data returned would be formatted, and\n            // no public examples available so http-ntp not supported for now.\n            // presumably you would do an arraybuffer type xhr and decode the\n            // binary data returned but I would want to see a sample first.\n            'urn:mpeg:dash:utc:http-ntp:2014':      notSupportedHandler,\n\n            // not clear how this would be supported in javascript (in browser)\n            'urn:mpeg:dash:utc:ntp:2014':           notSupportedHandler,\n            'urn:mpeg:dash:utc:sntp:2014':          notSupportedHandler\n        };\n\n        if (!getIsSynchronizing()) {\n            attemptSync(timingSources);\n            setIsInitialised(true);\n        }\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.metricsModel) {\n            metricsModel = config.metricsModel;\n        }\n\n        if (config.dashMetrics) {\n            dashMetrics = config.dashMetrics;\n        }\n\n        if (config.baseURLController) {\n            baseURLController = config.baseURLController;\n        }\n    }\n\n    function getOffsetToDeviceTimeMs() {\n        return getOffsetMs();\n    }\n\n    function setIsSynchronizing(value) {\n        isSynchronizing = value;\n    }\n\n    function getIsSynchronizing() {\n        return isSynchronizing;\n    }\n\n    function setIsInitialised(value) {\n        isInitialised = value;\n    }\n\n    function setOffsetMs(value) {\n        offsetToDeviceTimeMs = value;\n    }\n\n    function getOffsetMs() {\n        return offsetToDeviceTimeMs;\n    }\n\n    // takes xsdatetime and returns milliseconds since UNIX epoch\n    // may not be necessary as xsdatetime is very similar to ISO 8601\n    // which is natively understood by javascript Date parser\n    function alternateXsdatetimeDecoder(xsdatetimeStr) {\n        // taken from DashParser - should probably refactor both uses\n        const SECONDS_IN_MIN = 60;\n        const MINUTES_IN_HOUR = 60;\n        const MILLISECONDS_IN_SECONDS = 1000;\n        let datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\n\n        let utcDate,\n            timezoneOffset;\n\n        let match = datetimeRegex.exec(xsdatetimeStr);\n\n        // If the string does not contain a timezone offset different browsers can interpret it either\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\n        // all browsers\n        utcDate = Date.UTC(\n            parseInt(match[1], 10),\n            parseInt(match[2], 10) - 1, // months start from zero\n            parseInt(match[3], 10),\n            parseInt(match[4], 10),\n            parseInt(match[5], 10),\n            (match[6] && (parseInt(match[6], 10) || 0)),\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\n        );\n        // If the date has timezone offset take it into account as well\n        if (match[9] && match[10]) {\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\n        }\n\n        return new Date(utcDate).getTime();\n    }\n\n    // try to use the built in parser, since xsdate is a constrained ISO8601\n    // which is supported natively by Date.parse. if that fails, try a\n    // regex-based version used elsewhere in this application.\n    function xsdatetimeDecoder(xsdatetimeStr) {\n        let parsedDate = Date.parse(xsdatetimeStr);\n\n        if (isNaN(parsedDate)) {\n            parsedDate = alternateXsdatetimeDecoder(xsdatetimeStr);\n        }\n\n        return parsedDate;\n    }\n\n    // takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\n    function iso8601Decoder(isoStr) {\n        return Date.parse(isoStr);\n    }\n\n    // takes RFC 1123 timestamp (which is same as ISO8601) and returns\n    // milliseconds since UNIX epoch\n    function rfc1123Decoder(dateStr) {\n        return Date.parse(dateStr);\n    }\n\n    function notSupportedHandler(url, onSuccessCB, onFailureCB) {\n        onFailureCB();\n    }\n\n    function directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\n        let time = xsdatetimeDecoder(xsdatetimeStr);\n\n        if (!isNaN(time)) {\n            onSuccessCB(time);\n            return;\n        }\n\n        onFailureCB();\n    }\n\n    function httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\n        let oncomplete,\n            onload;\n        let complete = false;\n        let req = new XMLHttpRequest();\n\n        let verb = isHeadRequest ? HTTPRequest.HEAD : HTTPRequest.GET;\n        let urls = url.match(/\\S+/g);\n\n        // according to ISO 23009-1, url could be a white-space\n        // separated list of URLs. just handle one at a time.\n        url = urls.shift();\n\n        oncomplete = function () {\n            if (complete) {\n                return;\n            }\n\n            // we only want to pass through here once per xhr,\n            // regardless of whether the load was successful.\n            complete = true;\n\n            // if there are more urls to try, call self.\n            if (urls.length) {\n                httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\n            } else {\n                onFailureCB();\n            }\n        };\n\n        onload = function () {\n            let time,\n                result;\n\n            if (req.status === 200) {\n                time = isHeadRequest ?\n                        req.getResponseHeader('Date') :\n                        req.response;\n\n                result = decoder(time);\n\n                // decoder returns NaN if non-standard input\n                if (!isNaN(result)) {\n                    onSuccessCB(result);\n                    complete = true;\n                }\n            }\n        };\n\n        if (urlUtils.isRelative(url)) {\n            // passing no path to resolve will return just MPD BaseURL/baseUri\n            const baseUrl = baseURLController.resolve();\n            if (baseUrl) {\n                url = urlUtils.resolve(url, baseUrl.url);\n            }\n        }\n\n        req.open(verb, url);\n        req.timeout = HTTP_TIMEOUT_MS || 0;\n        req.onload = onload;\n        req.onloadend = oncomplete;\n        req.send();\n    }\n\n    function httpHeadHandler(url, onSuccessCB, onFailureCB) {\n        httpHandler(rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\n    }\n\n    function checkForDateHeader() {\n        let metrics = metricsModel.getReadOnlyMetricsFor(Constants.STREAM);\n        let dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID(metrics, 'Date');\n        let dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\n\n        if (!isNaN(dateHeaderTime)) {\n            setOffsetMs(dateHeaderTime - new Date().getTime());\n            completeTimeSyncSequence(false, dateHeaderTime / 1000, offsetToDeviceTimeMs);\n        }else {\n            completeTimeSyncSequence(true);\n        }\n    }\n\n    function completeTimeSyncSequence(failed, time, offset) {\n        setIsSynchronizing(false);\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED, { time: time, offset: offset, error: failed ? new DashJSError(TIME_SYNC_FAILED_ERROR_CODE) : null });\n    }\n\n    function attemptSync(sources, sourceIndex) {\n\n        // if called with no sourceIndex, use zero (highest priority)\n        let  index = sourceIndex || 0;\n\n        // the sources should be ordered in priority from the manifest.\n        // try each in turn, from the top, until either something\n        // sensible happens, or we run out of sources to try.\n        let source = sources[index];\n\n        // callback to emit event to listeners\n        const onComplete = function (time, offset) {\n            let failed = !time || !offset;\n            if (failed && useManifestDateHeaderTimeSource) {\n                //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\n                checkForDateHeader();\n            } else {\n                completeTimeSyncSequence(failed, time, offset);\n            }\n        };\n\n        setIsSynchronizing(true);\n\n        if (source) {\n            // check if there is a handler for this @schemeIdUri\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\n                // if so, call it with its @value\n                handlers[source.schemeIdUri](\n                    source.value,\n                    function (serverTime) {\n                        // the timing source returned something useful\n                        let deviceTime = new Date().getTime();\n                        let offset = serverTime - deviceTime;\n\n                        setOffsetMs(offset);\n\n                        log('Local time:      ' + new Date(deviceTime));\n                        log('Server time:     ' + new Date(serverTime));\n                        log('Difference (ms): ' + offset);\n\n                        onComplete(serverTime, offset);\n                    },\n                    function () {\n                        // the timing source was probably uncontactable\n                        // or returned something we can't use - try again\n                        // with the remaining sources\n                        attemptSync(sources, index + 1);\n                    }\n                );\n            } else {\n                // an unknown schemeIdUri must have been found\n                // try again with the remaining sources\n                attemptSync(sources, index + 1);\n            }\n        } else {\n            // no valid time source could be found, just use device time\n            setOffsetMs(0);\n            onComplete();\n        }\n    }\n\n    function reset() {\n        setIsInitialised(false);\n        setIsSynchronizing(false);\n    }\n\n    instance = {\n        initialize: initialize,\n        getOffsetToDeviceTimeMs: getOffsetToDeviceTimeMs,\n        setConfig: setConfig,\n        reset: reset\n    };\n\n    return instance;\n}\n\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\nlet factory = FactoryMaker.getSingletonFactory(TimeSyncController);\nfactory.TIME_SYNC_FAILED_ERROR_CODE = TIME_SYNC_FAILED_ERROR_CODE;\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\nFactoryMaker.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\nexport default factory;\n"]}