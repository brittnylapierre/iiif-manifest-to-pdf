{"version":3,"sources":["../../../../../../src/streaming/rules/abr/BolaRule.js"],"names":[],"mappings":"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","file":"BolaRule.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2016, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\n\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\n\nimport MetricsConstants from '../../constants/MetricsConstants';\nimport SwitchRequest from '../SwitchRequest';\nimport FactoryMaker from '../../../core/FactoryMaker';\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\nimport EventBus from '../../../core/EventBus';\nimport Events from '../../../core/events/Events';\nimport Debug from '../../../core/Debug';\n\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\nconst BOLA_STATE_ONE_BITRATE    = 0;\nconst BOLA_STATE_STARTUP        = 1;\nconst BOLA_STATE_STEADY         = 2;\n\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\nconst MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2;\n// E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\n\nconst PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\n\nfunction BolaRule(config) {\n\n    config = config || {};\n    const context = this.context;\n    const log = Debug(context).getInstance().log;\n\n    const dashMetrics = config.dashMetrics;\n    const metricsModel = config.metricsModel;\n    const mediaPlayerModel = config.mediaPlayerModel;\n    const eventBus = EventBus(context).getInstance();\n\n    let instance,\n        bolaStateDict;\n\n    function setup() {\n        resetInitialSettings();\n\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    function utilitiesFromBitrates(bitrates) {\n        return bitrates.map(b => Math.log(b));\n        // no need to worry about offset, utilities will be offset (uniformly) anyway later\n    }\n\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\n    function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\n        const highestUtilityIndex = utilities.reduce((highestIndex, u, uIndex) => (u > utilities[highestIndex] ? uIndex : highestIndex), 0);\n\n        if (highestUtilityIndex === 0) {\n            // if highestUtilityIndex === 0, then always use lowest bitrate\n            return null;\n        }\n\n        const bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length);\n\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\n        // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\n        // giving:\n        const gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\n        const Vp = MINIMUM_BUFFER_S / gp;\n        // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\n\n        return {gp: gp, Vp: Vp};\n    }\n\n    function getInitialBolaState(rulesContext) {\n        const initialState = {};\n        const mediaInfo = rulesContext.getMediaInfo();\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\n        let utilities = utilitiesFromBitrates(bitrates);\n        utilities = utilities.map(u => u - utilities[0] + 1); // normalize\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        const params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\n\n        if (!params) {\n            // only happens when there is only one bitrate level\n            initialState.state = BOLA_STATE_ONE_BITRATE;\n        } else {\n            initialState.state = BOLA_STATE_STARTUP;\n\n            initialState.bitrates = bitrates;\n            initialState.utilities = utilities;\n            initialState.stableBufferTime = stableBufferTime;\n            initialState.Vp = params.Vp;\n            initialState.gp = params.gp;\n\n            initialState.lastQuality = 0;\n            clearBolaStateOnSeek(initialState);\n        }\n\n        return initialState;\n    }\n\n    function clearBolaStateOnSeek(bolaState) {\n        bolaState.placeholderBuffer = 0;\n        bolaState.mostAdvancedSegmentStart = NaN;\n        bolaState.lastSegmentWasReplacement = false;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentDurationS = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n    }\n\n    // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\n    function checkBolaStateStableBufferTime(bolaState, mediaType) {\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\n        if (bolaState.stableBufferTime !== stableBufferTime) {\n            const params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\n            if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\n                // correct placeholder buffer using two criteria:\n                // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\n                // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\n\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\n                let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\n\n                effectiveBufferLevel -= MINIMUM_BUFFER_S;\n                effectiveBufferLevel *= params.Vp / bolaState.Vp;\n                effectiveBufferLevel += MINIMUM_BUFFER_S;\n\n                bolaState.stableBufferTime = stableBufferTime;\n                bolaState.Vp = params.Vp;\n                bolaState.gp = params.gp;\n                bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\n            }\n        }\n    }\n\n    function getBolaState(rulesContext) {\n        const mediaType = rulesContext.getMediaType();\n        let bolaState = bolaStateDict[mediaType];\n        if (!bolaState) {\n            bolaState = getInitialBolaState(rulesContext);\n            bolaStateDict[mediaType] = bolaState;\n        } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n            checkBolaStateStableBufferTime(bolaState, mediaType);\n        }\n        return bolaState;\n    }\n\n    // The core idea of BOLA.\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\n        const bitrateCount = bolaState.bitrates.length;\n        let quality = NaN;\n        let score = NaN;\n        for (let i = 0; i < bitrateCount; ++i) {\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\n            if (isNaN(score) || s >= score) {\n                score = s;\n                quality = i;\n            }\n        }\n        return quality;\n    }\n\n    // maximum buffer level which prefers to download at quality rather than wait\n    function maxBufferLevelForQuality(bolaState, quality) {\n        return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\n    }\n\n    // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\n    function minBufferLevelForQuality(bolaState, quality) {\n        const qBitrate = bolaState.bitrates[quality];\n        const qUtility = bolaState.utilities[quality];\n\n        let min = 0;\n        for (let i = quality - 1; i >= 0; --i) {\n            // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\n            if (bolaState.utilities[i] < bolaState.utilities[quality]) {\n                const iBitrate = bolaState.bitrates[i];\n                const iUtility = bolaState.utilities[i];\n\n                const level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\n                min = Math.max(min, level); // we want min to be small but at least level(i) for all i\n            }\n        }\n        return min;\n    }\n\n    /*\n     * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\n     * There are two main reasons we might want to increase the placeholder buffer:\n     *\n     * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\n     *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\n     *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\n     *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\n     *\n     * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\n     *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\n     *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\n     *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\n     */\n    function updatePlaceholderBuffer(bolaState, mediaType) {\n        const nowMs = Date.now();\n\n        if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n            // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\n            const delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        } else if (!isNaN(bolaState.lastCallTimeMs)) {\n            // no download after last call, compensate for delay between calls\n            const delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\n            bolaState.placeholderBuffer += Math.max(0, delay);\n        }\n\n        bolaState.lastCallTimeMs = nowMs;\n        bolaState.lastSegmentStart = NaN;\n        bolaState.lastSegmentRequestTimeMs = NaN;\n        bolaState.lastSegmentFinishTimeMs = NaN;\n\n        checkBolaStateStableBufferTime(bolaState, mediaType);\n    }\n\n    function onBufferEmpty() {\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\n                bolaStateDict[mediaType].placeholderBuffer = 0;\n            }\n        }\n    }\n\n    function onPlaybackSeeking() {\n        // TODO: 1. Verify what happens if we seek mid-fragment.\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\n        for (const mediaType in bolaStateDict) {\n            if (bolaStateDict.hasOwnProperty(mediaType)) {\n                const bolaState = bolaStateDict[mediaType];\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                    bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\n                    clearBolaStateOnSeek(bolaState);\n                }\n            }\n        }\n    }\n\n    function onPeriodSwitchStarted() {\n        // TODO: does this have to be handled here?\n    }\n\n    function onMediaFragmentLoaded(e) {\n        if (e && e.chunk && e.chunk.mediaInfo) {\n            const bolaState = bolaStateDict[e.chunk.mediaInfo.type];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                const start = e.chunk.start;\n                if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\n                    bolaState.mostAdvancedSegmentStart = start;\n                    bolaState.lastSegmentWasReplacement = false;\n                } else {\n                    bolaState.lastSegmentWasReplacement = true;\n                }\n\n                bolaState.lastSegmentStart = start;\n                bolaState.lastSegmentDurationS = e.chunk.duration;\n                bolaState.lastQuality = e.chunk.quality;\n\n                checkNewSegment(bolaState, e.chunk.mediaInfo.type);\n            }\n        }\n    }\n\n    function onMetricAdded(e) {\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\n                bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\n\n                checkNewSegment(bolaState, e.mediaType);\n            }\n        }\n    }\n\n    /*\n     * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\n     * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\n     * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\n     * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\n     * decides not to increase the quality to avoid oscillations.\n     *\n     * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\n     * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\n     * We avoid this by growing the placeholder buffer.\n     */\n    function checkNewSegment(bolaState, mediaType) {\n        if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\n            bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY;\n\n            // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\n            if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\n                const bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\n                const maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\n                const maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\n                bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\n            }\n\n            // then see if we should grow placeholder buffer\n\n            if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\n                // compensate for segments that were downloaded but did not grow the buffer\n                bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\n            }\n\n            bolaState.lastSegmentStart = NaN;\n            bolaState.lastSegmentRequestTimeMs = NaN;\n        }\n    }\n\n    function onQualityChangeRequested(e) {\n        // Useful to store change requests when abandoning a download.\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                bolaState.abrQuality = e.newQuality;\n            }\n        }\n    }\n\n    function onFragmentLoadingAbandoned(e) {\n        if (e) {\n            const bolaState = bolaStateDict[e.mediaType];\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\n                // deflate placeholderBuffer - note that we want to be conservative when abandoning\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(e.mediaType));\n                let wantEffectiveBufferLevel;\n                if (bolaState.abrQuality > 0) {\n                    // deflate to point where BOLA just chooses newQuality over newQuality-1\n                    wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\n                } else {\n                    wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\n                }\n                const maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\n                bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\n            }\n        }\n    }\n\n    function getMaxIndex(rulesContext) {\n        const mediaInfo = rulesContext.getMediaInfo();\n        const mediaType = rulesContext.getMediaType();\n        const metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\n        const streamProcessor = rulesContext.getStreamProcessor();\n        const streamInfo = rulesContext.getStreamInfo();\n        const abrController = rulesContext.getAbrController();\n        const throughputHistory = abrController.getThroughputHistory();\n        const streamId = streamInfo ? streamInfo.id : null;\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\n        const useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\n        const switchRequest = SwitchRequest(context).create();\n        switchRequest.reason = switchRequest.reason || {};\n\n        if (!useBufferOccupancyABR) {\n            return switchRequest;\n        }\n\n        streamProcessor.getScheduleController().setTimeToLoadDelay(0);\n\n        const bolaState = getBolaState(rulesContext);\n\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\n            // shouldn't even have been called\n            log('BOLA ABR rule invoked for media type \\'' + mediaType + '\\' with only one bitrate.');\n            return switchRequest;\n        }\n\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\n        const latency = throughputHistory.getAverageLatency(mediaType);\n        let quality;\n\n        switchRequest.reason.state = bolaState.state;\n        switchRequest.reason.throughput = throughput;\n        switchRequest.reason.latency = latency;\n\n        if (isNaN(throughput)) { // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\n            // still starting up - not enough information\n            return switchRequest;\n        }\n\n        switch (bolaState.state) {\n            case BOLA_STATE_STARTUP:\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = safeThroughput;\n\n                bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\n                bolaState.lastQuality = quality;\n\n                if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\n                    bolaState.state = BOLA_STATE_STEADY;\n                }\n\n                break; // BOLA_STATE_STARTUP\n\n            case BOLA_STATE_STEADY:\n\n                // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\n                //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\n                //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\n                //     However, the InsufficientBufferRule takes care of this scenario.\n\n                updatePlaceholderBuffer(bolaState, mediaType);\n\n                quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer);\n\n                // we want to avoid oscillations\n                // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\n                const qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\n                    // only intervene if we are trying to *increase* quality to an *unsustainable* level\n                    // we are only avoid oscillations - do not drop below last quality\n\n                    quality = Math.max(qualityForThroughput, bolaState.lastQuality);\n                }\n\n                // We do not want to overfill buffer with low quality chunks.\n                // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\n                let delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality));\n\n                // First reduce placeholder buffer, then tell schedule controller to pause.\n                if (delayS <= bolaState.placeholderBuffer) {\n                    bolaState.placeholderBuffer -= delayS;\n                    delayS = 0;\n                } else {\n                    delayS -= bolaState.placeholderBuffer;\n                    bolaState.placeholderBuffer = 0;\n\n                    if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\n                        // At top quality, allow schedule controller to decide how far to fill buffer.\n                        streamProcessor.getScheduleController().setTimeToLoadDelay(1000 * delayS);\n                    } else {\n                        delayS = 0;\n                    }\n                }\n\n                switchRequest.quality = quality;\n                switchRequest.reason.throughput = throughput;\n                switchRequest.reason.latency = latency;\n                switchRequest.reason.bufferLevel = bufferLevel;\n                switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\n                switchRequest.reason.delay = delayS;\n\n                bolaState.lastQuality = quality;\n                // keep bolaState.state === BOLA_STATE_STEADY\n\n                break; // BOLA_STATE_STEADY\n\n            default:\n                log('BOLA ABR rule invoked in bad state.');\n                // should not arrive here, try to recover\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\n                switchRequest.reason.state = bolaState.state;\n                switchRequest.reason.throughput = safeThroughput;\n                switchRequest.reason.latency = latency;\n                bolaState.state = BOLA_STATE_STARTUP;\n                clearBolaStateOnSeek(bolaState);\n        }\n\n        return switchRequest;\n    }\n\n    function resetInitialSettings() {\n        bolaStateDict = {};\n    }\n\n    function reset() {\n        resetInitialSettings();\n\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\n        eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\n    }\n\n    instance = {\n        getMaxIndex: getMaxIndex,\n        reset: reset\n    };\n\n    setup();\n    return instance;\n}\n\nBolaRule.__dashjs_factory_name = 'BolaRule';\nexport default FactoryMaker.getClassFactory(BolaRule);\n"]}