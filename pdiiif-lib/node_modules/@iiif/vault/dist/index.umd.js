(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.IIIFVault = {}));
})(this, (function (exports) { 'use strict';

  const k={id:"https://iiif-parser/annotation-page",type:"AnnotationPage",behavior:[],motivation:null,label:null,thumbnail:[],summary:null,requiredStatement:null,metadata:[],rights:null,provider:[],items:[],seeAlso:[],homepage:[],logo:[],rendering:[],service:[]},N={id:"https://iiif-parser/empty-canvas",type:"Canvas",label:null,behavior:[],motivation:null,thumbnail:[],posterCanvas:null,accompanyingCanvas:null,placeholderCanvas:null,summary:null,requiredStatement:null,metadata:[],rights:null,navDate:null,provider:[],items:[],annotations:[],seeAlso:[],homepage:[],logo:[],partOf:[],rendering:[],service:[],duration:0,height:0,width:0},$={id:"https://iiif-parser/empty-collection",type:"Collection",label:null,viewingDirection:"left-to-right",behavior:[],motivation:null,thumbnail:[],posterCanvas:null,accompanyingCanvas:null,placeholderCanvas:null,summary:null,requiredStatement:null,metadata:[],rights:null,navDate:null,provider:[],items:[],annotations:[],seeAlso:[],homepage:[],logo:[],partOf:[],rendering:[],service:[],services:[]},j={id:"https://iiif-parser/empty-manifest",type:"Manifest",annotations:[],behavior:[],homepage:[],items:[],label:null,logo:[],metadata:[],motivation:null,navDate:null,provider:[],partOf:[],posterCanvas:null,accompanyingCanvas:null,placeholderCanvas:null,rendering:[],requiredStatement:null,rights:null,seeAlso:[],service:[],services:[],start:null,structures:[],summary:null,thumbnail:[],viewingDirection:"left-to-right"},G={id:"https://iiif-parser/empty-canvas",type:"Range",label:null,behavior:[],motivation:null,thumbnail:[],posterCanvas:null,accompanyingCanvas:null,placeholderCanvas:null,summary:null,requiredStatement:null,metadata:[],rights:null,navDate:null,provider:[],items:[],annotations:[],seeAlso:[],homepage:[],logo:[],partOf:[],rendering:[],service:[],start:null,supplementary:null,viewingDirection:"left-to-right"},q={id:"https://iiif-parser/empty-agent",type:"Agent",label:{},logo:[],seeAlso:[],homepage:[]},M=["Collection","Manifest","Canvas","AnnotationPage","AnnotationCollection","Annotation","ContentResource","Range","Service","Selector","Agent"];function U(t){if(typeof t=="undefined"||t===null)throw new Error("Null or undefined is not a valid entity.");if(Array.isArray(t))throw new Error("Array is not a valid entity");if(typeof t!="object")throw new Error(`${typeof t} is not a valid entity`);if(typeof t.type=="string"){const e=M.indexOf(t.type);if(e!==-1)return M[e]}if(t.profile)return "Service";throw new Error("Resource type is not known")}class L{traversals;options;constructor(e,i={}){this.traversals={collection:[],manifest:[],canvas:[],annotationCollection:[],annotationPage:[],annotation:[],contentResource:[],choice:[],range:[],service:[],agent:[],...e},this.options={allowUndefinedReturn:!1,...i};}static all(e){return new L({collection:[e],manifest:[e],canvas:[e],annotationCollection:[e],annotationPage:[e],annotation:[e],contentResource:[e],choice:[e],range:[e],service:[e]})}traverseDescriptive(e){return e.thumbnail&&(e.thumbnail=e.thumbnail.map(i=>this.traverseType(i,this.traversals.contentResource))),e.provider&&(e.provider=e.provider.map(i=>this.traverseAgent(i))),e}traverseLinking(e){return e.seeAlso&&(e.seeAlso=e.seeAlso.map(i=>this.traverseType(i,this.traversals.contentResource))),e.service&&(e.service=e.service.map(i=>this.traverseType(i,this.traversals.service))),e.services&&(e.services=e.services.map(i=>this.traverseType(i,this.traversals.service))),e.logo&&(e.logo=e.logo.map(i=>this.traverseType(i,this.traversals.contentResource))),e.homepage&&(e.homepage=e.homepage.map(i=>this.traverseType(i,this.traversals.contentResource))),e.partOf&&(e.partOf=e.partOf.map(i=>typeof i=="string"||!i.type?this.traverseType(i,this.traversals.contentResource):i.type==="Canvas"?this.traverseType(i,this.traversals.canvas):i.type==="AnnotationCollection"?this.traverseType(i,this.traversals.annotationCollection):this.traverseType(i,this.traversals.contentResource))),e.start&&(e.start=e.start?this.traverseType(e.start,this.traversals.canvas):null),e.rendering&&(e.rendering=e.rendering.map(i=>this.traverseType(i,this.traversals.contentResource))),e.supplementary&&(e.supplementary=e.supplementary.map(i=>this.traverseType(i,this.traversals.contentResource))),e}traverseCollectionItems(e){return e.items&&e.items.map(i=>i.type==="Collection"?this.traverseCollection(i):this.traverseManifest(i)),e}traverseCollection(e){return this.traverseType(this.traverseDescriptive(this.traverseInlineAnnotationPages(this.traverseLinking(this.traversePosterCanvas(this.traverseCollectionItems(e))))),this.traversals.collection)}traverseManifestItems(e){return e.items&&(e.items=e.items.map(i=>this.traverseCanvas(i))),e}traverseManifestStructures(e){return e.structures&&(e.structures=e.structures.map(i=>this.traverseRange(i))),e}traverseManifest(e){return this.traverseType(this.traverseInlineAnnotationPages(this.traverseManifestStructures(this.traversePosterCanvas(this.traverseDescriptive(this.traverseLinking(this.traverseManifestItems(e)))))),this.traversals.manifest)}traverseCanvasItems(e){return e.items=(e.items||[]).map(i=>this.traverseAnnotationPage(i)),e}traverseInlineAnnotationPages(e){return typeof e=="string"||!e||e.annotations&&(e.annotations=e.annotations.map(i=>this.traverseAnnotationPage(i))),e}traverseCanvas(e){return this.traverseType(this.traverseInlineAnnotationPages(this.traversePosterCanvas(this.traverseDescriptive(this.traverseLinking(this.traverseCanvasItems(e))))),this.traversals.canvas)}traverseAnnotationPageItems(e){return e.items&&(e.items=e.items.map(i=>this.traverseAnnotation(i))),e}traverseAnnotationPage(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationPageItems(e))),this.traversals.annotationPage)}traverseAnnotationBody(e){return Array.isArray(e.body)?e.body=e.body.map(i=>this.traverseContentResource(i)):e.body&&(e.body=this.traverseContentResource(e.body)),e}traversePosterCanvas(e){return e.posterCanvas&&(e.posterCanvas=this.traverseType(e.posterCanvas,this.traversals.canvas)),e.placeholderCanvas&&(e.placeholderCanvas=this.traverseType(e.placeholderCanvas,this.traversals.canvas)),e.accompanyingCanvas&&(e.accompanyingCanvas=this.traverseType(e.accompanyingCanvas,this.traversals.canvas)),e}traverseAnnotation(e){return this.traverseType(this.traverseLinking(this.traverseAnnotationBody(e)),this.traversals.annotation)}traverseContentResourceLinking(e){return typeof e=="string"||!e||e&&e.service&&(e.service=(e.service||[]).map(i=>this.traverseType(i,this.traversals.service))),e}traverseContentResource(e){return e.type==="Choice"&&(e.items=e.items.map(i=>this.traverseContentResource(i))),this.traverseType(this.traverseInlineAnnotationPages(this.traverseContentResourceLinking(e)),this.traversals.contentResource)}traverseRangeRanges(e){return e.items&&(e.items=e.items.map(i=>typeof i=="string"?this.traverseCanvas({id:i,type:"Canvas"}):i.type==="Manifest"?this.traverseManifest(i):this.traverseRange(i))),e}traverseRange(e){return this.traverseType(this.traversePosterCanvas(this.traverseDescriptive(this.traverseLinking(this.traverseRangeRanges(e)))),this.traversals.range)}traverseAgent(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(e)),this.traversals.agent)}traverseType(e,i){return i.reduce((n,r)=>{const a=r(n);return typeof a=="undefined"&&!this.options.allowUndefinedReturn?n:a},e)}traverseService(e){return this.traverseType(e,this.traversals.service)}traverseUnknown(e){const i=U(e);switch(i){case"Collection":return this.traverseCollection(e);case"Manifest":return this.traverseManifest(e);case"Canvas":return this.traverseCanvas(e);case"AnnotationPage":return this.traverseAnnotationPage(e);case"Annotation":return this.traverseAnnotation(e);case"ContentResource":return this.traverseContentResource(e);case"Range":return this.traverseRange(e);case"Service":return this.traverseService(e);case"Agent":return this.traverseAgent(e);default:throw new Error(`Unknown or unsupported resource type of ${i}`)}}}const V=["sc:Collection","sc:Manifest","sc:Canvas","oa:AnnotationList","oa:Annotation","sc:Range","sc:Layer","sc:Sequence","oa:Choice","Service","ContentResource"];function Ie(t){if(typeof t=="undefined"||t===null)throw new Error("Null or undefined is not a valid entity.");if(Array.isArray(t))throw new Error("Array is not a valid entity");if(typeof t!="object")throw new Error(`${typeof t} is not a valid entity`);if(typeof t["@type"]=="string"){const e=V.indexOf(t["@type"]);if(e!==-1)return V[e]}if(t.profile)return "Service";if(t.format||t["@type"])return "ContentResource";throw new Error("Resource type is not known")}class x{traversals;options;constructor(e,i={}){this.traversals={collection:[],manifest:[],canvas:[],annotationList:[],sequence:[],annotation:[],contentResource:[],choice:[],range:[],service:[],layer:[],...e},this.options={convertPropsToArray:!0,mergeMemberProperties:!0,allowUndefinedReturn:!1,...i};}static all(e){return new x({collection:[e],manifest:[e],canvas:[e],annotationList:[e],sequence:[e],annotation:[e],contentResource:[e],choice:[e],range:[e],service:[e],layer:[e]})}traverseCollection(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseCollectionItems(e))),this.traversals.collection)}traverseCollectionItems(e){if(this.options.mergeMemberProperties){const i=[...(e.manifests||[]).map(n=>typeof n=="string"?{"@id":n,"@type":"sc:Manifest"}:n),...(e.collections||[]).map(n=>typeof n=="string"?{"@id":n,"@type":"sc:Collection"}:n),...e.members||[]];delete e.collections,delete e.manifests,e.members=i;}return e.manifests&&(e.manifests=e.manifests.map(i=>this.traverseManifest(typeof i=="string"?{"@id":i,"@type":"sc:Manifest"}:i))),e.collections&&(e.collections=e.collections.map(i=>this.traverseCollection(typeof i=="string"?{"@id":i,"@type":"sc:Collection"}:i))),e.members&&(e.members=e.members.map(i=>typeof i=="string"?i:this.traverseUnknown(i))),e}traverseManifest(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseManifestItems(e))),this.traversals.manifest)}traverseManifestItems(e){return e.sequences&&(e.sequences=e.sequences.map(i=>this.traverseSequence(i))),e.structures&&(e.structures=e.structures.map(i=>this.traverseRange(i))),e}traverseSequence(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseSequenceItems(e))),this.traversals.sequence)}traverseSequenceItems(e){return e.canvases&&(e.canvases=e.canvases.map(i=>this.traverseCanvas(i))),e}traverseCanvas(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseCanvasItems(e))),this.traversals.canvas)}traverseCanvasItems(e){return e.images&&(e.images=e.images.map(i=>this.traverseAnnotation(i))),e.otherContent&&(e.otherContent=e.otherContent.map(i=>this.traverseAnnotationList(i))),e}traverseRange(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseRangeItems(e))),this.traversals.range)}traverseRangeItems(e){if(this.options.mergeMemberProperties){const i=[...(e.ranges||[]).map(n=>typeof n=="string"?{"@id":n,"@type":"sc:Range"}:n),...(e.canvases||[]).map(n=>typeof n=="string"?{"@id":n,"@type":"sc:Canvas"}:n),...e.members||[]];delete e.ranges,delete e.canvases,e.members=i.length?i.map(n=>this.traverseUnknown(n)):void 0;}return e}traverseAnnotationList(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationListItems(e))),this.traversals.annotationList)}traverseAnnotationListItems(e){return e.resources&&(e.resources=e.resources.map(i=>this.traverseAnnotation(i))),e}traverseAnnotation(e){return this.traverseType(this.traverseDescriptive(this.traverseLinking(this.traverseAnnotationItems(e))),this.traversals.annotation)}traverseAnnotationItems(e){return e.resource&&(e.resource=this.traverseContentResource(e.resource)),e.on,e}traverseLayer(e){return this.traverseType(this.traverseLinking(this.traverseLayerItems(e)),this.traversals.layer)}traverseLayerItems(e){return e.otherContent&&(e.otherContent=e.otherContent.map(i=>this.traverseAnnotationList(i))),e}traverseChoice(e){return this.traverseType(this.traverseChoiceItems(e),this.traversals.choice)}traverseChoiceItems(e){return e.default&&e.default!=="rdf:nil"&&(e.default=this.traverseContentResource(e.default)),e.item&&e.item!=="rdf:nil"&&(e.item=e.item.map(i=>this.traverseContentResource(i))),e}traverseService(e){return this.traverseType(this.traverseLinking(e),this.traversals.service)}traverseContentResource(e){return e["@type"]==="oa:Choice"?this.traverseChoice(e):this.traverseType(this.traverseDescriptive(this.traverseLinking(e)),this.traversals.contentResource)}traverseUnknown(e){if(!e["@type"]||typeof e=="string")return e;switch(Ie(e)){case"sc:Collection":return this.traverseCollection(e);case"sc:Manifest":return this.traverseManifest(e);case"sc:Canvas":return this.traverseCanvas(e);case"sc:Sequence":return this.traverseSequence(e);case"sc:Range":return this.traverseRange(e);case"oa:Annotation":return this.traverseAnnotation(e);case"oa:AnnotationList":return this.traverseAnnotationList(e);case"sc:Layer":return this.traverseLayer(e);case"Service":return this.traverseService(e);case"oa:Choice":return this.traverseChoice(e);case"ContentResource":return this.traverseContentResource(e)}return e.profile?this.traverseService(e):e}traverseImageResource(e){const i=Array.isArray(e),n=Array.isArray(e)?e:[e],r=[];for(const a of n)typeof a=="string"?r.push(this.traverseContentResource({"@id":a,"@type":"dctypes:Image"})):r.push(this.traverseContentResource(a));return !i&&!this.options.convertPropsToArray?r[0]:r}traverseDescriptive(e){return e.thumbnail&&(e.thumbnail=this.traverseImageResource(e.thumbnail)),e.logo&&(e.logo=this.traverseImageResource(e.logo)),e}traverseOneOrMoreServices(e){const i=Array.isArray(e),n=Array.isArray(e)?e:[e],r=[];for(const a of n)r.push(this.traverseService(a));return !i&&!this.options.convertPropsToArray?r[0]:r}traverseLinking(e){return e.related&&(e.related=this.traverseOneOrManyType(e.related,this.traversals.contentResource)),e.rendering&&(e.rendering=this.traverseOneOrManyType(e.rendering,this.traversals.contentResource)),e.service&&(e.service=this.traverseOneOrMoreServices(e.service)),e.seeAlso&&(e.seeAlso=this.traverseOneOrManyType(e.seeAlso,this.traversals.contentResource)),e.within&&(typeof e.within=="string"||(e.within=this.traverseOneOrManyType(e.within,this.traversals.contentResource))),e.startCanvas&&(typeof e.startCanvas=="string"?e.startCanvas=this.traverseType({"@id":e.startCanvas,"@type":"sc:Canvas"},this.traversals.canvas):e.startCanvas&&this.traverseType(e.startCanvas,this.traversals.canvas)),e.contentLayer&&(typeof e.contentLayer=="string"?e.contentLayer=this.traverseLayer({"@id":e.contentLayer,"@type":"sc:Layer"}):e.contentLayer=this.traverseLayer(e.contentLayer)),e}traverseOneOrManyType(e,i){if(!Array.isArray(e))if(this.options.convertPropsToArray)e=[e];else return this.traverseType(e,i);return e.map(n=>this.traverseType(n,i))}traverseType(e,i){return i.reduce((n,r)=>{const a=r(n);return typeof a=="undefined"&&!this.options.allowUndefinedReturn?n:a},e)}}const _e="http://library.stanford.edu/iiif/image-api/compliance.html#level0",W="http://library.stanford.edu/iiif/image-api/compliance.html#level1",z="http://library.stanford.edu/iiif/image-api/compliance.html#level2",be="http://library.stanford.edu/iiif/image-api/conformance.html#level0",B="http://library.stanford.edu/iiif/image-api/conformance.html#level1",H="http://library.stanford.edu/iiif/image-api/conformance.html#level2",Re="http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level0",K="http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level1",Q="http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2",we="http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level0",X="http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level1",Y="http://library.stanford.edu/iiif/image-api/1.1/conformance.html#level2",Ee="http://iiif.io/api/image/1/level0.json",Le="http://iiif.io/api/image/1/profiles/level0.json",Z="http://iiif.io/api/image/1/level1.json",J="http://iiif.io/api/image/1/profiles/level1.json",ee="http://iiif.io/api/image/1/level2.json",te="http://iiif.io/api/image/1/profiles/level2.json",Te="http://iiif.io/api/image/2/level0.json",Me="http://iiif.io/api/image/2/profiles/level0.json",ie="http://iiif.io/api/image/2/level1.json",ne="http://iiif.io/api/image/2/profiles/level1.json",re="http://iiif.io/api/image/2/level2.json",ae="http://iiif.io/api/image/2/profiles/level2.json",xe="level0",se="level1",oe="level2",Se="http://iiif.io/api/image/2/level0",le="http://iiif.io/api/image/2/level1",ve="http://iiif.io/api/image/2/level2",Oe=[le,ve,W,z,B,H,K,Q,X,Y,Z,J,ee,te,ie,ne,re,ae,se,oe],Pe=[Se,le,ve,_e,W,z,be,B,H,Re,K,Q,we,X,Y,Ee,Le,Z,J,ee,te,Te,Me,ie,ne,re,ae,xe,se,oe],S={attributionLabel:"Attribution",lang:"none",providerId:"http://example.org/provider",providerName:"Unknown"};function u$1(t,e="none"){if(!t)return {};const i=Array.isArray(t)?t:[t],n={};for(const r of i){if(typeof r=="string"){n[e]=n[e]?n[e]:[],n[e].push(r||"");continue}if(!r["@language"]){n[e]=n[e]?n[e]:[],n[e].push(r["@value"]||"");continue}const a=r["@language"];n[a]=n[a]?n[a]:[],n[a].push(r["@value"]||"");}return n}function pe(t){if(Array.isArray(t))return pe(t.find(e=>typeof e=="string"));if(Pe.indexOf(t)!==-1)return "level2";if(Oe.indexOf(t)!==-1)return "level1";if(typeof t=="string")return t}function Fe(t){const e=Array.isArray(t)?t:[t];for(const i of e)switch(i){case"http://iiif.io/api/image/2/context.json":case"http://library.stanford.edu/iiif/image-api/1.1/compliance.html#level2":return "ImageService2";case"http://iiif.io/api/image/1/context.json":case"http://library.stanford.edu/iiif/image-api/1.1/context.json":return "ImageService1";case"http://iiif.io/api/annex/openannotation/context.json":return "ImageApiSelector"}}function De(t){switch(t){case"http://iiif.io/api/image/2/level0.json":case"http://iiif.io/api/image/2/level1.json":case"http://iiif.io/api/image/2/level2.json":return "ImageService2";case"http://iiif.io/api/auth/1/kiosk":case"http://iiif.io/api/auth/1/login":case"http://iiif.io/api/auth/1/clickthrough":case"http://iiif.io/api/auth/1/external":case"http://iiif.io/api/auth/0/kiosk":case"http://iiif.io/api/auth/0/login":case"http://iiif.io/api/auth/0/clickthrough":case"http://iiif.io/api/auth/0/external":return "AuthCookieService1";case"http://iiif.io/api/auth/1/token":case"http://iiif.io/api/auth/0/token":return "AuthTokenService1";case"http://iiif.io/api/auth/1/logout":case"http://iiif.io/api/auth/0/logout":return "AuthLogoutService1";case"http://iiif.io/api/search/1/search":case"http://iiif.io/api/search/0/search":return "SearchService1";case"http://iiif.io/api/search/1/autocomplete":case"http://iiif.io/api/search/0/autocomplete":return "AutoCompleteService1"}}function ke(t){return Array.isArray(t)?t:[t]}function Ne(t){for(const e of ["sc","oa","dcterms","dctypes","iiif"])if(t.startsWith(`${e}:`))return t.slice(e.length+1);return t}const $e=["Collection","Manifest","Annotation","AnnotationPage","Range","Service"];function O(t){const e=t["@id"]||t.id;let i=t["@type"]||t.type;const n=t.profile||void 0,r=t["@context"]||void 0;if(n){const a=De(n);if(a)return a}if(r){const a=Fe(r);if(a)return a}if(i){if(Array.isArray(i)){if(i.indexOf("oa:CssStylesheet")!==-1)return "CssStylesheet";if(i.indexOf("cnt:ContentAsText")!==-1)return "TextualBody";i=i[0];}for(const a of ["sc","oa","dcterms","dctypes","iiif"])if(i.startsWith(`${a}:`)){i=i.slice(a.length+1);break}switch(i){case"Layer":return "AnnotationCollection";case"AnnotationList":return "AnnotationPage";case"cnt:ContentAsText":return "TextualBody"}}if(i&&$e.indexOf(i)!==-1)return i;if(t.format){if(t.format.startsWith("image/"))return "Image";if(t.format.startsWith("text/")||t.format==="application/pdf")return "Text";if(t.format.startsWith("application/"))return "Dataset"}return e&&(e.endsWith(".jpg")||e.endsWith(".png")||e.endsWith(".jpeg"))?"Image":i||"unknown"}const je=/http(s)?:\/\/(creativecommons.org|rightsstatements.org)[^"'\\<\n]+/gm;function Ge(t){const e=t.match(je);return e?e[0]:t}function qe(t,e="Rights/License",i="none"){let n=null;const r=[],a=Array.isArray(t)?t:[t];for(const I of a){const o=I?Ge(I):void 0;if(o&&(o.indexOf("creativecommons.org")!==-1||o.indexOf("rightsstatements.org")!==-1)){o.startsWith("https://")?n=`http://${o.slice(8)}`:n=o;continue}o&&r.push({label:{[i]:[e]},value:{[i]:[o]}});}return [n,r]}const Ue=["http://iiif.io/api/presentation/2/context.json","http://iiif.io/api/image/2/context.json","http://iiif.io/api/image/1/context.json","http://library.stanford.edu/iiif/image-api/1.1/context.json","http://iiif.io/api/search/1/context.json","http://iiif.io/api/search/0/context.json","http://iiif.io/api/auth/1/context.json","http://iiif.io/api/auth/0/context.json","http://iiif.io/api/annex/openannotation/context.json"];function Ve(t){if(t){const e=Array.isArray(t)?t:[t],i=[];for(const n of e)n==="http://iiif.io/api/presentation/2/context.json"&&i.push("http://iiif.io/api/presentation/3/context.json"),Ue.indexOf(n)===-1&&i.push(n);if(e.length)return i.length===1?i[0]:i}}function We(t){return t?t.map(e=>({label:u$1(e.label),value:u$1(e.value)})):[]}function v(t){for(const e in t)(typeof t[e]=="undefined"||t[e]===null)&&delete t[e];return t}let he=0;function ce(t,e){const i=encodeURI(t.id||t["@id"]||"").trim();return i&&e?`${i}/${e}`:i||(he++,`http://example.org/${t["@type"]}${e?`/${e}`:""}/${he}`)}function p(t){const e=[...t.behavior||[]];return t.viewingHint&&e.push(t.viewingHint),{"@context":t["@context"]?Ve(t["@context"]):void 0,id:(t["@id"]||ce(t)).trim(),type:O(t),behavior:e.length?e:void 0,height:t.height?t.height:void 0,width:t.width?t.width:void 0,motivation:t.motivation?Ne(t.motivation):void 0,viewingDirection:t.viewingDirection,profile:t.profile,format:t.format?t.format:void 0,duration:void 0,timeMode:void 0}}function l(t){const[e,i]=qe(t.license),n=[...t.metadata?We(t.metadata):[],...i];return {rights:e,metadata:n.length?n:void 0,label:t.label?u$1(t.label):void 0,requiredStatement:t.attribution?{label:u$1(S.attributionLabel),value:u$1(t.attribution)}:void 0,navDate:t.navDate,summary:t.description?u$1(t.description):void 0,thumbnail:t.thumbnail}}function ze(t){if(!t.within)return;const e=Array.isArray(t.within)?t.within:[t.within],i=[];for(const n of e)if(typeof n=="string"){if(n)switch(t["@type"]){case"sc:Manifest":i.push({id:n,type:"Collection"});break}}else n["@id"]&&i.push({id:n["@id"],type:O(n)});return i.length?i:void 0}function h(t){const e=t.related?Array.isArray(t.related)?t.related:[t.related]:[],i=t.contentLayer;return {provider:t.logo||e.length?[{id:S.providerId,type:"Agent",homepage:e.length?[e[0]]:void 0,logo:t.logo?Array.isArray(t.logo)?t.logo:[t.logo]:void 0,label:u$1(S.providerName)}]:void 0,partOf:ze(t),rendering:t.rendering,seeAlso:t.seeAlso,start:t.startCanvas,service:t.service?ke(t.service):void 0,supplementary:i?[i]:void 0}}function Be(t){return v({...p(t),...l(t),...h(t),items:t.members})}function He(t){const e=[],i=[];for(const r of t.sequences||[])r.canvases.length&&e.push(...r.canvases),r.behavior&&i.push(...r.behavior);const n=p(t);return i.length&&(n.behavior?n.behavior.push(...i):n.behavior=i),v({...n,...l(t),...h(t),items:e,structures:t.structures})}function Ke(t){return v({...p(t),...l(t),...h(t),items:t.images&&t.images.length?[{id:ce(t,"annotation-page"),type:"AnnotationPage",items:t.images}]:void 0})}function Qe(t){return v({...p(t),...l(t),...h(t),items:t.resources})}function Xe(t){return !t.canvases||t.canvases.length===0?{canvases:[],behavior:[]}:{canvases:t.canvases,behavior:t.viewingHint?[t.viewingHint]:[]}}function Ye(t){return v({...p(t),...l(t),...h(t),target:typeof t.on=="string"?encodeURI(t.on).trim():t.on,body:t.resource})}function Ze(t){const e=t;return v({...p(e),...l(e),...h(e)})}function Je(t){const e=[];return t.default&&t.default!=="rdf:nil"&&e.push(t.default),t.item&&t.item!=="rdf:nil"&&e.push(...t.item),{...p(t),...l(t),items:e}}function et(t){return v({...p(t),...l(t),...h(t),items:t.members})}function tt(t){const{"@id":e,"@type":i,"@context":n,profile:r,...a}=t;return e&&(a.id=e),a.type=O(t),a.type==="unknown"&&(a.type="Service"),r&&(a.profile=pe(r)),v({...a,...l(a)})}function it(t){return v({...p(t),...l(t),...h(t)})}const nt=new x({collection:[Be],manifest:[He],canvas:[Ke],annotationList:[Qe],sequence:[Xe],annotation:[Ye],contentResource:[Ze],choice:[Je],range:[et],service:[tt],layer:[it]});function rt(t){return t&&t["@context"]&&(t["@context"]==="http://iiif.io/api/presentation/2/context.json"||t["@context"].indexOf("http://iiif.io/api/presentation/2/context.json")!==-1||t["@context"]==="http://www.shared-canvas.org/ns/context.json")||t["@context"]==="http://iiif.io/api/image/2/context.json"?nt.traverseUnknown(t):t}function fe(){return {Collection:{},Manifest:{},Canvas:{},AnnotationPage:{},AnnotationCollection:{},Annotation:{},ContentResource:{},Range:{},Service:{},Selector:{},Agent:{}}}function ue(t,e){if(typeof t=="string")return {id:t,type:e};if(!t.id)throw new Error(`Invalid resource does not have an ID (${e})`);return t}function st(t){return (e,i)=>{const n=t[e]?t[e]:{};return r=>{const a=ue(r,i||e);return a&&a.id&&e?(n[a.id]=n[a.id]?Object.assign({},n[a.id],a):Object.assign({},a),{id:a.id,type:e==="ContentResource"?e:a.type}):a}}}function ot(t){return (e,i)=>n=>{const{id:r,type:a}=ue(n,i||e);if(typeof r=="undefined")throw new Error("Found invalid entity without an ID.");return e==="ContentResource"?t[r]=e:t[r]=a,n}}function lt(t){const e=JSON.stringify(t);let i=5381,n=e.length;for(;n;)i=i*33^e.charCodeAt(--n);const a=(i>>>0).toString(16);return a.length%2?"0"+a:a}function P(t){return e=>typeof e=="string"?{id:e,type:t}:e.id?e.type?e:{type:t,...e}:{id:`vault://${lt(e)}`,type:t,...e}}function _(t){return e=>({...t,...e})}function b(t){return Array.isArray(t)?t:[t]}function vt(t){return t.body&&(t.body=b(t.body)),t.seeAlso&&(t.seeAlso=b(t.seeAlso)),t.body&&(t.body=b(t.body)),t.audience&&(t.audience=b(t.audience)),t.accessibility&&(t.accessibility=b(t.accessibility)),t.motivation&&(t.motivation=b(t.motivation)),t}function pt(t){const e=rt(t),i=fe(),n={},r=st(i),a=ot(n),o=new L({collection:[_($),a("Collection"),r("Collection")],manifest:[_(j),a("Manifest"),r("Manifest")],canvas:[_(N),a("Canvas"),r("Canvas")],annotationPage:[P("AnnotationPage"),_(k),a("AnnotationPage"),r("AnnotationPage")],annotation:[P("Annotation"),vt,a("Annotation"),r("Annotation")],contentResource:[P("ContentResource"),a("ContentResource"),r("ContentResource")],range:[_(G),a("Range","Canvas"),r("Range","Canvas")],agent:[_(q),a("Agent"),r("Agent")]}).traverseUnknown(e);return {entities:i,resource:o,mapping:n}}const c="__$UNSET$__",F="__$UNWRAP$__";function ht(t,e){const i=t.requests[e],n=t.mapping[e];if(!(!n||i&&i.resourceUri&&!t.entities[n][i.resourceUri]))return t.entities[n][i?i.resourceUri:e]}function de(t){const e={};for(const[i,n]of t){if(i===F&&n!==c)return n;n!==c&&typeof n!="undefined"&&n!==null&&(e[i]=n);}return e}function ct(t,e,i){if(!e.type||!e.id)throw new Error("Unknown entity");if(!i[e.type])throw new Error(`Serializer not found for ${e.type}`);function n(r){const a=i[r.type];if(!a)return c;const I=ht(t,r.id)||(r.id&&r.type?r:null);if(!I)return c;const o=a(I,t,{isTopLevel:e.id===r.id});let R=o.next();for(;!R.done;){const E=R.value;let T=c;if(E)if(Array.isArray(E)){const D=[];for(const Ae of E)D.push(n(Ae));T=D;}else T=n(E);R=o.next(T);}return R.value===c?c:de(R.value)}return n(e)}function d(t){if(!t)return;const e=Object.keys(t);if(e.length!==0){if(e.length===1){const i=e[0];if(!i)return "";const n=(t[i]||[]).join("");return i==="@none"||i==="none"||i==="en"?n:{"@language":i,"@value":n}}return e.map(i=>({"@language":i,"@value":(t[i]||[]).join("")}))}}function me(t){return Array.isArray(t)?t.map(e=>me(e)):typeof t=="string"?t:t.type&&t.type==="Canvas"?t.id:t}function f(t,e=!1){if(!!t)return t.length>1&&!e?t:t[0]||void 0}function ft(t){if(!!t){if(typeof t=="string")return {"@id":t};if("@id"in t){const e={...t};return delete e["@type"],e}return {"@context":"http://iiif.io/api/image/2/context.json","@id":t.id,profile:`http://iiif.io/api/image/2/profiles/${t.profile}.json`}}}function m(t,e){return [["@id",t.id],["@type",e],["format",t.format],["height",t.height],["width",t.width],["viewingDirection",t.viewingDirection!=="left-to-right"?t.viewingDirection:void 0]]}function*g(t){const e=t.provider?yield t.provider[0]:void 0;return [["label",d(t.label)],["metadata",t.metadata&&t.metadata.length?t.metadata.map(i=>({label:d(i.label)||"",value:d(i.value)||""})):void 0],["description",d(t.summary)],["thumbnail",f(yield t.thumbnail)],["navDate",t.navDate],["logo",e?f(e.logo):void 0],["homepage",e?e.homepage:void 0],["attribution",t.requiredStatement?d(t.requiredStatement.value):void 0]]}function*w(t){return [["seeAlso",f(yield t.seeAlso)],["service",f((t.service||[]).map(ft))],["rendering",f(yield t.rendering)],["startCanvas",t.start?t.start.id:void 0]]}const ut={Manifest:function*(t){return [...m(t,"sc:Manifest"),...yield*g(t),...yield*w(t),["sequences",[{"@id":`${t.id}/sequence0`,"@type":"sc:Sequence",canvases:yield t.items}]],["structures",yield t.structures]]},Canvas:function*(t){const i=(yield t.items)[0];return [...m(t,"sc:Canvas"),...yield*g(t),...yield*w(t),["images",i?[i.resources]:void 0],["annotations",t.annotations&&t.annotations.length?f(yield t.annotations):void 0]]},AnnotationPage:function*(t){return [...m(t,"sc:AnnotationList"),...yield*g(t),["resources",t.items&&t.items.length?f(yield t.items):void 0]]},Annotation:function*(t){return [["@id",t.id],["@type","oa:Annotation"],["motivation","sc:painting"],["on",me(t.target)],["resource",f(yield t.body,!0)]]},ContentResource:function*(t){switch(t.type){case"Image":return [...m(t,"dctypes:Image"),...yield*g(t),...yield*w(t)];case"Text":case"Dataset":default:return [...m(t,void 0),...yield*g(t)]}},AnnotationCollection:function*(t){return [["@id",t.id],["@type","sc:Layer"],["label",d(t.label)]]},Collection:function*(t){return [...m(t,"sc:Collection"),...yield*g(t),...yield*w(t),["members",yield*t.items]]},Range:function*(t){const e=[],i=[];if(t.items)for(const n of t.items){const r=yield n;e.push({"@id":n.id,"@type":n.type,label:r?r.label:void 0,within:t.id}),n.type==="Canvas"&&i.push(n.id);}return [...m(t,"sc:Range"),...yield*g(t),...yield*w(t),["canvases",i.length===e.length?i:void 0],["members",i.length!==e.length?e:void 0]]}};function y$1(t){return [["id",t.id?.startsWith("vault://")?void 0:t.id],["type",t.type],["format",t.format],["profile",t.profile],["height",t.height],["width",t.width],["duration",t.duration||void 0],["viewingDirection",t.viewingDirection!=="left-to-right"?t.viewingDirection:void 0],["behavior",t.behavior&&t.behavior.length?t.behavior:void 0],["timeMode",t.timeMode],["motivation",Array.isArray(t.motivation)?t.motivation[0]:t.motivation]]}function s$1(t){if(!(!t||t.length===0))return t}function ge(t){if(t&&t.type&&t.type==="ImageService2"){const{id:e,type:i,profile:n,...r}=t;return {"@id":e,"@type":i,profile:n.startsWith("http")?n:`http://iiif.io/api/image/2/${n}.json`,...r}}return t}function ye(t){if(!(!t||t.length===0))return t.map(ge)}function*A(t){return [["label",t.label],["metadata",s$1(t.metadata)],["summary",t.summary],["requiredStatement",t.requiredStatement],["rights",t.rights],["navDate",t.navDate],["language",t.language],["thumbnail",s$1(yield t.thumbnail)],["placeholderCanvas",yield t.placeholderCanvas],["accompanyingCanvas",yield t.accompanyingCanvas],["provider",s$1(yield t.provider)]]}function*C(t){return [["seeAlso",s$1(yield t.seeAlso)],["service",ye(t.service)],["services",ye(t.services)],["rendering",s$1(yield t.rendering)],["supplementary",s$1(yield t.supplementary)],["homepage",s$1(yield t.homepage)],["logo",s$1(yield t.logo)],["partOf",s$1(yield t.partOf)],["start",t.start]]}const dt={Manifest:function*(t,e,{isTopLevel:i}){return i?[["@context","http://iiif.io/api/presentation/3/context.json"],...y$1(t),...yield*A(t),...yield*C(t),["items",yield t.items],["structures",s$1(yield t.structures)],["annotations",s$1(yield t.annotations)]]:[...y$1(t),...yield*A(t)]},Canvas:function*(t){return [...y$1(t),...yield*A(t),...yield*C(t),["items",yield t.items],["annotations",s$1(yield t.annotations)]]},Agent:function*(t){return [["id",t.id],["type","Agent"],["label",t.label],...yield*C(t)]},AnnotationPage:function*(t){return [...Object.entries(t).map(([i,n])=>[i,Array.isArray(n)?s$1(n):n]).filter(([i,n])=>i!=="items"),...yield*C(t),["items",yield t.items]]},Service:function*(t){return [[F,ge(t)]]},Annotation:function*(t){const e=Object.entries(t).map(([n,r])=>n==="motivation"?[n,Array.isArray(r)?r[0]:r]:[n,Array.isArray(r)?s$1(r):r]).filter(([n])=>n!=="body"),i=yield t.body;return [...e,["body",i.length===1?i[0]:i]]},ContentResource:function*(t){return [...y$1(t),...yield*A(t),...yield*C(t),["annotations",s$1(yield t.annotations)],["items",s$1(yield t.items)]]},AnnotationCollection:function*(t){return [["id",t.id],["type","AnnotationCollection"],["label",t.label]]},Collection:function*(t,e,{isTopLevel:i}){return i?[["@context","http://iiif.io/api/presentation/3/context.json"],...y$1(t),...yield*A(t),...yield*C(t),["items",s$1(yield t.items)]]:[...y$1(t),...yield*A(t)]},Range:function*(t){const e=[];for(const i of t.items)i.type==="Range"?e.push(yield i):e.push(i);return [...y$1(t),...yield*A(t),...yield*C(t),["items",e],["annotations",s$1(yield t.annotations)]]}};

  function n(n){return null==n}function t(n){throw new Error("Argument "+n+" is empty.")}function o(n){return "string"==typeof n||"symbol"==typeof n}function u(n){return !o(n)}function a(n){throw new Error("Argument "+n+" is invalid, it should be an action type of type: string | symbol")}function s(r,e){n(r)&&t(1),u(r)&&a(1);return Object.assign((function(){var n=null!=e?e.apply(void 0,arguments):void 0;return Object.assign({type:r},n)}),{getType:function(){return r},toString:function(){return r}})}function y(r,e,i){return n(r)&&t(1),u(r)&&a(1),function(){return s(r,(function(){var n=arguments.length<=0?void 0:arguments[0],t=arguments.length<=1?void 0:arguments[1];return null==e&&null==i||(n=null!=e?e.apply(void 0,arguments):void 0,t=null!=i?i.apply(void 0,arguments):void 0),Object.assign({},void 0!==n&&{payload:n},{},void 0!==t&&{meta:t})}))}}

  const IMPORT_ENTITIES = "@iiif/IMPORT_ENTITIES";
  const MODIFY_ENTITY_FIELD = "@iiif/MODIFY_ENTITY_FIELD";
  const REORDER_ENTITY_FIELD = "@iiif/REORDER_ENTITY_FIELD";
  const ADD_REFERENCE = "@iiif/ADD_REFERENCE";
  const REMOVE_REFERENCE = "@iiif/REMOVE_REFERENCE";
  const importEntities = y(IMPORT_ENTITIES)();
  const modifyEntityField = y(MODIFY_ENTITY_FIELD)();
  const reorderEntityField = y(REORDER_ENTITY_FIELD)();
  const addReference = y(ADD_REFERENCE)();
  const removeReference = y(REMOVE_REFERENCE)();
  const entityActions = { importEntities, modifyEntityField, reorderEntityField, addReference, removeReference };

  const ADD_MAPPING = "@iiif/ADD_MAPPING";
  const ADD_MAPPINGS = "@iiif/ADD_MAPPINGS";
  const addMapping = y(ADD_MAPPING)();
  const addMappings = y(ADD_MAPPINGS)();

  const SET_META_VALUE = "@iiif/SET_META_VALUE";
  const SET_META_VALUE_DYNAMIC = "@iiif/SET_META_VALUE_DYNAMIC";
  const UNSET_META_VALUE = "@iiif/UNSET_META_VALUE";
  const setMetaValue = y(SET_META_VALUE)();
  const setMetaValueDynamic = y(SET_META_VALUE_DYNAMIC)();
  const unsetMetaValue = y(UNSET_META_VALUE)();
  const metaActions = {
    setMetaValue,
    setMetaValueDynamic,
    unsetMetaValue
  };

  const RESOURCE_ERROR = "RESOURCE_ERROR";
  const RESOURCE_LOADING = "RESOURCE_LOADING";
  const RESOURCE_READY = "RESOURCE_READY";
  const REQUEST_RESOURCE = "@iiif/REQUEST_RESOURCE";
  const REQUEST_ERROR = "@iiif/REQUEST_ERROR";
  const REQUEST_MISMATCH = "@iiif/REQUEST_MISMATCH";
  const REQUEST_COMPLETE = "@iiif/REQUEST_COMPLETE";
  const REQUEST_OFFLINE_RESOURCE = "@iiif/REQUEST_OFFLINE_RESOURCE";
  const requestResource = y(REQUEST_RESOURCE)();
  const requestError = y(REQUEST_ERROR)();
  const requestMismatch = y(REQUEST_MISMATCH)();
  const requestComplete = y(REQUEST_COMPLETE)();
  y(REQUEST_OFFLINE_RESOURCE)();

  const BATCH_ACTIONS = "@iiif/BATCH";
  const BATCH_IMPORT = "@iiif/BATCH_IMPORT";
  const batchActions = y(BATCH_ACTIONS)();
  y(BATCH_IMPORT)();

  const actionListFromResource = (id, response) => {
    const { entities, resource, mapping } = pt(response);
    if (resource.id === void 0) {
      return [requestError({ id, message: "ID is not defined in resource." })];
    }
    const actions = [importEntities({ entities }), addMappings({ mapping })];
    if (resource.id !== id) {
      actions.push(addMapping({ id, type: resource.type }));
      actions.push(requestMismatch({ requestId: id, actualId: resource.id }));
    }
    actions.push(requestComplete({ id }));
    return actions;
  };

  const safeIsNaN = Number.isNaN || function ponyfill(value) {
    return typeof value === "number" && value !== value;
  };
  function isEqual(first, second) {
    if (first === second) {
      return true;
    }
    if (safeIsNaN(first) && safeIsNaN(second)) {
      return true;
    }
    return false;
  }
  function areInputsEqual(newInputs, lastInputs) {
    if (!Array.isArray(newInputs) || !Array.isArray(lastInputs)) {
      return newInputs === lastInputs;
    }
    if (newInputs.length !== lastInputs.length) {
      return false;
    }
    for (let i = 0; i < newInputs.length; i++) {
      if (!isEqual(newInputs[i], lastInputs[i])) {
        return false;
      }
    }
    return true;
  }

  function resolveIfExists(state, url) {
    const request = state.iiif.requests[url];
    const resourceType = state.iiif.mapping[url];
    if (!resourceType || !state.iiif.entities[resourceType][request.resourceUri]) {
      return void 0;
    }
    return state.iiif.entities[resourceType][request.resourceUri];
  }

  function createFetchHelper(store, fetcher, { waitTimeout = 30 } = {}) {
    return async (url, options) => {
      const state = store.getState();
      const request = state.iiif.requests[url];
      if (request) {
        switch (request.loadingState) {
          case RESOURCE_ERROR:
            break;
          case RESOURCE_LOADING: {
            let cleanupSubscription;
            let didContinue = false;
            try {
              const resolvedEntity = await Promise.race([
                new Promise((resolve, reject) => {
                  if (didContinue) {
                    return;
                  }
                  cleanupSubscription = store.subscribe(() => {
                    const latestState = store.getState();
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_ERROR) {
                      reject();
                      return;
                    }
                    if (latestState.iiif.requests[url].loadingState === RESOURCE_READY) {
                      const maybeResolvedEntity = resolveIfExists(latestState, url);
                      if (maybeResolvedEntity) {
                        resolve(maybeResolvedEntity);
                      } else {
                        reject();
                      }
                    }
                  });
                }),
                new Promise((resolve, reject) => setTimeout(() => {
                  didContinue = true;
                  reject();
                }, waitTimeout * 60))
              ]);
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              if (resolvedEntity) {
                return resolvedEntity;
              }
            } catch (e) {
              if (cleanupSubscription) {
                cleanupSubscription();
              }
              break;
            }
            break;
          }
          case RESOURCE_READY: {
            const resolvedEntity = resolveIfExists(state, url);
            if (resolvedEntity) {
              return resolvedEntity;
            }
            break;
          }
        }
      }
      store.dispatch(requestResource({ id: url }));
      try {
        const resource = await fetcher(url, options);
        if (!resource.id && !resource["@id"]) {
          if (resource["@type"]) {
            resource["@id"] = url;
            resource.id = url;
          } else {
            resource.id = url;
          }
        }
        const toDispatch = actionListFromResource(url, resource);
        store.dispatch(batchActions({ actions: toDispatch }));
        return resolveIfExists(store.getState(), url);
      } catch (err) {
        store.dispatch(requestError({ id: url, message: err.toString() }));
        throw err;
      }
    };
  }

  function getDefaultEntities() {
    return {
      Collection: {},
      Manifest: {},
      Canvas: {},
      AnnotationPage: {},
      AnnotationCollection: {},
      Annotation: {},
      ContentResource: {},
      Range: {},
      Service: {},
      Selector: {},
      Agent: {}
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }

    return target;
  }

  // Inlined version of the `symbol-observable` polyfill
  var $$observable = (function () {
    return typeof Symbol === 'function' && Symbol.observable || '@@observable';
  })();

  /**
   * These are private action types reserved by Redux.
   * For any unknown actions, you must return the current state.
   * If the current state is undefined, you must return the initial state.
   * Do not reference these action types directly in your code.
   */
  var randomString = function randomString() {
    return Math.random().toString(36).substring(7).split('').join('.');
  };

  var ActionTypes = {
    INIT: "@@redux/INIT" + randomString(),
    REPLACE: "@@redux/REPLACE" + randomString(),
    PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
      return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
    }
  };

  /**
   * @param {any} obj The object to inspect.
   * @returns {boolean} True if the argument appears to be a plain object.
   */
  function isPlainObject(obj) {
    if (typeof obj !== 'object' || obj === null) return false;
    var proto = obj;

    while (Object.getPrototypeOf(proto) !== null) {
      proto = Object.getPrototypeOf(proto);
    }

    return Object.getPrototypeOf(obj) === proto;
  }

  // Inlined / shortened version of `kindOf` from https://github.com/jonschlinkert/kind-of
  function miniKindOf(val) {
    if (val === void 0) return 'undefined';
    if (val === null) return 'null';
    var type = typeof val;

    switch (type) {
      case 'boolean':
      case 'string':
      case 'number':
      case 'symbol':
      case 'function':
        {
          return type;
        }
    }

    if (Array.isArray(val)) return 'array';
    if (isDate(val)) return 'date';
    if (isError(val)) return 'error';
    var constructorName = ctorName(val);

    switch (constructorName) {
      case 'Symbol':
      case 'Promise':
      case 'WeakMap':
      case 'WeakSet':
      case 'Map':
      case 'Set':
        return constructorName;
    } // other


    return type.slice(8, -1).toLowerCase().replace(/\s/g, '');
  }

  function ctorName(val) {
    return typeof val.constructor === 'function' ? val.constructor.name : null;
  }

  function isError(val) {
    return val instanceof Error || typeof val.message === 'string' && val.constructor && typeof val.constructor.stackTraceLimit === 'number';
  }

  function isDate(val) {
    if (val instanceof Date) return true;
    return typeof val.toDateString === 'function' && typeof val.getDate === 'function' && typeof val.setDate === 'function';
  }

  function kindOf(val) {
    var typeOfVal = typeof val;

    {
      typeOfVal = miniKindOf(val);
    }

    return typeOfVal;
  }

  /**
   * Creates a Redux store that holds the state tree.
   * The only way to change the data in the store is to call `dispatch()` on it.
   *
   * There should only be a single store in your app. To specify how different
   * parts of the state tree respond to actions, you may combine several reducers
   * into a single reducer function by using `combineReducers`.
   *
   * @param {Function} reducer A function that returns the next state tree, given
   * the current state tree and the action to handle.
   *
   * @param {any} [preloadedState] The initial state. You may optionally specify it
   * to hydrate the state from the server in universal apps, or to restore a
   * previously serialized user session.
   * If you use `combineReducers` to produce the root reducer function, this must be
   * an object with the same shape as `combineReducers` keys.
   *
   * @param {Function} [enhancer] The store enhancer. You may optionally specify it
   * to enhance the store with third-party capabilities such as middleware,
   * time travel, persistence, etc. The only store enhancer that ships with Redux
   * is `applyMiddleware()`.
   *
   * @returns {Store} A Redux store that lets you read the state, dispatch actions
   * and subscribe to changes.
   */

  function createStore$1(reducer, preloadedState, enhancer) {
    var _ref2;

    if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
      throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function. See https://redux.js.org/tutorials/fundamentals/part-4-store#creating-a-store-with-enhancers for an example.');
    }

    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
      enhancer = preloadedState;
      preloadedState = undefined;
    }

    if (typeof enhancer !== 'undefined') {
      if (typeof enhancer !== 'function') {
        throw new Error("Expected the enhancer to be a function. Instead, received: '" + kindOf(enhancer) + "'");
      }

      return enhancer(createStore$1)(reducer, preloadedState);
    }

    if (typeof reducer !== 'function') {
      throw new Error("Expected the root reducer to be a function. Instead, received: '" + kindOf(reducer) + "'");
    }

    var currentReducer = reducer;
    var currentState = preloadedState;
    var currentListeners = [];
    var nextListeners = currentListeners;
    var isDispatching = false;
    /**
     * This makes a shallow copy of currentListeners so we can use
     * nextListeners as a temporary list while dispatching.
     *
     * This prevents any bugs around consumers calling
     * subscribe/unsubscribe in the middle of a dispatch.
     */

    function ensureCanMutateNextListeners() {
      if (nextListeners === currentListeners) {
        nextListeners = currentListeners.slice();
      }
    }
    /**
     * Reads the state tree managed by the store.
     *
     * @returns {any} The current state tree of your application.
     */


    function getState() {
      if (isDispatching) {
        throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
      }

      return currentState;
    }
    /**
     * Adds a change listener. It will be called any time an action is dispatched,
     * and some part of the state tree may potentially have changed. You may then
     * call `getState()` to read the current state tree inside the callback.
     *
     * You may call `dispatch()` from a change listener, with the following
     * caveats:
     *
     * 1. The subscriptions are snapshotted just before every `dispatch()` call.
     * If you subscribe or unsubscribe while the listeners are being invoked, this
     * will not have any effect on the `dispatch()` that is currently in progress.
     * However, the next `dispatch()` call, whether nested or not, will use a more
     * recent snapshot of the subscription list.
     *
     * 2. The listener should not expect to see all state changes, as the state
     * might have been updated multiple times during a nested `dispatch()` before
     * the listener is called. It is, however, guaranteed that all subscribers
     * registered before the `dispatch()` started will be called with the latest
     * state by the time it exits.
     *
     * @param {Function} listener A callback to be invoked on every dispatch.
     * @returns {Function} A function to remove this change listener.
     */


    function subscribe(listener) {
      if (typeof listener !== 'function') {
        throw new Error("Expected the listener to be a function. Instead, received: '" + kindOf(listener) + "'");
      }

      if (isDispatching) {
        throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
      }

      var isSubscribed = true;
      ensureCanMutateNextListeners();
      nextListeners.push(listener);
      return function unsubscribe() {
        if (!isSubscribed) {
          return;
        }

        if (isDispatching) {
          throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api/store#subscribelistener for more details.');
        }

        isSubscribed = false;
        ensureCanMutateNextListeners();
        var index = nextListeners.indexOf(listener);
        nextListeners.splice(index, 1);
        currentListeners = null;
      };
    }
    /**
     * Dispatches an action. It is the only way to trigger a state change.
     *
     * The `reducer` function, used to create the store, will be called with the
     * current state tree and the given `action`. Its return value will
     * be considered the **next** state of the tree, and the change listeners
     * will be notified.
     *
     * The base implementation only supports plain object actions. If you want to
     * dispatch a Promise, an Observable, a thunk, or something else, you need to
     * wrap your store creating function into the corresponding middleware. For
     * example, see the documentation for the `redux-thunk` package. Even the
     * middleware will eventually dispatch plain object actions using this method.
     *
     * @param {Object} action A plain object representing “what changed”. It is
     * a good idea to keep actions serializable so you can record and replay user
     * sessions, or use the time travelling `redux-devtools`. An action must have
     * a `type` property which may not be `undefined`. It is a good idea to use
     * string constants for action types.
     *
     * @returns {Object} For convenience, the same action object you dispatched.
     *
     * Note that, if you use a custom middleware, it may wrap `dispatch()` to
     * return something else (for example, a Promise you can await).
     */


    function dispatch(action) {
      if (!isPlainObject(action)) {
        throw new Error("Actions must be plain objects. Instead, the actual type was: '" + kindOf(action) + "'. You may need to add middleware to your store setup to handle dispatching other values, such as 'redux-thunk' to handle dispatching functions. See https://redux.js.org/tutorials/fundamentals/part-4-store#middleware and https://redux.js.org/tutorials/fundamentals/part-6-async-logic#using-the-redux-thunk-middleware for examples.");
      }

      if (typeof action.type === 'undefined') {
        throw new Error('Actions may not have an undefined "type" property. You may have misspelled an action type string constant.');
      }

      if (isDispatching) {
        throw new Error('Reducers may not dispatch actions.');
      }

      try {
        isDispatching = true;
        currentState = currentReducer(currentState, action);
      } finally {
        isDispatching = false;
      }

      var listeners = currentListeners = nextListeners;

      for (var i = 0; i < listeners.length; i++) {
        var listener = listeners[i];
        listener();
      }

      return action;
    }
    /**
     * Replaces the reducer currently used by the store to calculate the state.
     *
     * You might need this if your app implements code splitting and you want to
     * load some of the reducers dynamically. You might also need this if you
     * implement a hot reloading mechanism for Redux.
     *
     * @param {Function} nextReducer The reducer for the store to use instead.
     * @returns {void}
     */


    function replaceReducer(nextReducer) {
      if (typeof nextReducer !== 'function') {
        throw new Error("Expected the nextReducer to be a function. Instead, received: '" + kindOf(nextReducer));
      }

      currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
      // Any reducers that existed in both the new and old rootReducer
      // will receive the previous state. This effectively populates
      // the new state tree with any relevant data from the old one.

      dispatch({
        type: ActionTypes.REPLACE
      });
    }
    /**
     * Interoperability point for observable/reactive libraries.
     * @returns {observable} A minimal observable of state changes.
     * For more information, see the observable proposal:
     * https://github.com/tc39/proposal-observable
     */


    function observable() {
      var _ref;

      var outerSubscribe = subscribe;
      return _ref = {
        /**
         * The minimal observable subscription method.
         * @param {Object} observer Any object that can be used as an observer.
         * The observer object should have a `next` method.
         * @returns {subscription} An object with an `unsubscribe` method that can
         * be used to unsubscribe the observable from the store, and prevent further
         * emission of values from the observable.
         */
        subscribe: function subscribe(observer) {
          if (typeof observer !== 'object' || observer === null) {
            throw new Error("Expected the observer to be an object. Instead, received: '" + kindOf(observer) + "'");
          }

          function observeState() {
            if (observer.next) {
              observer.next(getState());
            }
          }

          observeState();
          var unsubscribe = outerSubscribe(observeState);
          return {
            unsubscribe: unsubscribe
          };
        }
      }, _ref[$$observable] = function () {
        return this;
      }, _ref;
    } // When a store is created, an "INIT" action is dispatched so that every
    // reducer returns their initial state. This effectively populates
    // the initial state tree.


    dispatch({
      type: ActionTypes.INIT
    });
    return _ref2 = {
      dispatch: dispatch,
      subscribe: subscribe,
      getState: getState,
      replaceReducer: replaceReducer
    }, _ref2[$$observable] = observable, _ref2;
  }

  /**
   * Prints a warning in the console if it exists.
   *
   * @param {String} message The warning message.
   * @returns {void}
   */
  function warning(message) {
    /* eslint-disable no-console */
    if (typeof console !== 'undefined' && typeof console.error === 'function') {
      console.error(message);
    }
    /* eslint-enable no-console */


    try {
      // This error was thrown as a convenience so that if you enable
      // "break on all exceptions" in your console,
      // it would pause the execution at this line.
      throw new Error(message);
    } catch (e) {} // eslint-disable-line no-empty

  }

  function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
    var reducerKeys = Object.keys(reducers);
    var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

    if (reducerKeys.length === 0) {
      return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
    }

    if (!isPlainObject(inputState)) {
      return "The " + argumentName + " has unexpected type of \"" + kindOf(inputState) + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
    }

    var unexpectedKeys = Object.keys(inputState).filter(function (key) {
      return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
    });
    unexpectedKeys.forEach(function (key) {
      unexpectedKeyCache[key] = true;
    });
    if (action && action.type === ActionTypes.REPLACE) return;

    if (unexpectedKeys.length > 0) {
      return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
    }
  }

  function assertReducerShape(reducers) {
    Object.keys(reducers).forEach(function (key) {
      var reducer = reducers[key];
      var initialState = reducer(undefined, {
        type: ActionTypes.INIT
      });

      if (typeof initialState === 'undefined') {
        throw new Error("The slice reducer for key \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
      }

      if (typeof reducer(undefined, {
        type: ActionTypes.PROBE_UNKNOWN_ACTION()
      }) === 'undefined') {
        throw new Error("The slice reducer for key \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle '" + ActionTypes.INIT + "' or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
      }
    });
  }
  /**
   * Turns an object whose values are different reducer functions, into a single
   * reducer function. It will call every child reducer, and gather their results
   * into a single state object, whose keys correspond to the keys of the passed
   * reducer functions.
   *
   * @param {Object} reducers An object whose values correspond to different
   * reducer functions that need to be combined into one. One handy way to obtain
   * it is to use ES6 `import * as reducers` syntax. The reducers may never return
   * undefined for any action. Instead, they should return their initial state
   * if the state passed to them was undefined, and the current state for any
   * unrecognized action.
   *
   * @returns {Function} A reducer function that invokes every reducer inside the
   * passed object, and builds a state object with the same shape.
   */


  function combineReducers(reducers) {
    var reducerKeys = Object.keys(reducers);
    var finalReducers = {};

    for (var i = 0; i < reducerKeys.length; i++) {
      var key = reducerKeys[i];

      {
        if (typeof reducers[key] === 'undefined') {
          warning("No reducer provided for key \"" + key + "\"");
        }
      }

      if (typeof reducers[key] === 'function') {
        finalReducers[key] = reducers[key];
      }
    }

    var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
    // keys multiple times.

    var unexpectedKeyCache;

    {
      unexpectedKeyCache = {};
    }

    var shapeAssertionError;

    try {
      assertReducerShape(finalReducers);
    } catch (e) {
      shapeAssertionError = e;
    }

    return function combination(state, action) {
      if (state === void 0) {
        state = {};
      }

      if (shapeAssertionError) {
        throw shapeAssertionError;
      }

      {
        var warningMessage = getUnexpectedStateShapeWarningMessage(state, finalReducers, action, unexpectedKeyCache);

        if (warningMessage) {
          warning(warningMessage);
        }
      }

      var hasChanged = false;
      var nextState = {};

      for (var _i = 0; _i < finalReducerKeys.length; _i++) {
        var _key = finalReducerKeys[_i];
        var reducer = finalReducers[_key];
        var previousStateForKey = state[_key];
        var nextStateForKey = reducer(previousStateForKey, action);

        if (typeof nextStateForKey === 'undefined') {
          var actionType = action && action.type;
          throw new Error("When called with an action of type " + (actionType ? "\"" + String(actionType) + "\"" : '(unknown type)') + ", the slice reducer for key \"" + _key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.");
        }

        nextState[_key] = nextStateForKey;
        hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
      }

      hasChanged = hasChanged || finalReducerKeys.length !== Object.keys(state).length;
      return hasChanged ? nextState : state;
    };
  }

  /**
   * Composes single-argument functions from right to left. The rightmost
   * function can take multiple arguments as it provides the signature for
   * the resulting composite function.
   *
   * @param {...Function} funcs The functions to compose.
   * @returns {Function} A function obtained by composing the argument functions
   * from right to left. For example, compose(f, g, h) is identical to doing
   * (...args) => f(g(h(...args))).
   */
  function compose() {
    for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
      funcs[_key] = arguments[_key];
    }

    if (funcs.length === 0) {
      return function (arg) {
        return arg;
      };
    }

    if (funcs.length === 1) {
      return funcs[0];
    }

    return funcs.reduce(function (a, b) {
      return function () {
        return a(b.apply(void 0, arguments));
      };
    });
  }

  /**
   * Creates a store enhancer that applies middleware to the dispatch method
   * of the Redux store. This is handy for a variety of tasks, such as expressing
   * asynchronous actions in a concise manner, or logging every action payload.
   *
   * See `redux-thunk` package as an example of the Redux middleware.
   *
   * Because middleware is potentially asynchronous, this should be the first
   * store enhancer in the composition chain.
   *
   * Note that each middleware will be given the `dispatch` and `getState` functions
   * as named arguments.
   *
   * @param {...Function} middlewares The middleware chain to be applied.
   * @returns {Function} A store enhancer applying the middleware.
   */

  function applyMiddleware() {
    for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
      middlewares[_key] = arguments[_key];
    }

    return function (createStore) {
      return function () {
        var store = createStore.apply(void 0, arguments);

        var _dispatch = function dispatch() {
          throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
        };

        var middlewareAPI = {
          getState: store.getState,
          dispatch: function dispatch() {
            return _dispatch.apply(void 0, arguments);
          }
        };
        var chain = middlewares.map(function (middleware) {
          return middleware(middlewareAPI);
        });
        _dispatch = compose.apply(void 0, chain)(store.dispatch);
        return _objectSpread2(_objectSpread2({}, store), {}, {
          dispatch: _dispatch
        });
      };
    };
  }

  /*
   * This is a dummy function to check if the function name has been altered by minification.
   * If the function has been minified and NODE_ENV !== 'production', warn the user.
   */

  function isCrushed() {}

  if (typeof isCrushed.name === 'string' && isCrushed.name !== 'isCrushed') {
    warning('You are currently using minified code outside of NODE_ENV === "production". ' + 'This means that you are running a slower development build of Redux. ' + 'You can use loose-envify (https://github.com/zertosh/loose-envify) for browserify ' + 'or setting mode to production in webpack (https://webpack.js.org/concepts/mode/) ' + 'to ensure you have the correct code for your production build.');
  }

  const mappingReducer = (state = {}, action) => {
    switch (action.type) {
      case ADD_MAPPING:
        return {
          ...state,
          [action.payload.id]: action.payload.type
        };
      case ADD_MAPPINGS:
        return {
          ...state,
          ...action.payload.mapping
        };
      default:
        return state;
    }
  };

  function isReferenceList(state, id, type, key) {
    return !(!state[type] || !state[type][id] || !state[type][id][key] || !Array.isArray(state[type][id][key]));
  }

  const entitiesReducer = (state = getDefaultEntities(), action) => {
    switch (action.type) {
      case MODIFY_ENTITY_FIELD: {
        if (!state[action.payload.type] || !state[action.payload.type][action.payload.id]) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        if (typeof entity === "string") {
          return state;
        }
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: action.payload.value
            }
          }
        };
      }
      case REORDER_ENTITY_FIELD: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        if (typeof entity === "string") {
          return state;
        }
        const result = Array.from(entity[action.payload.key]);
        const [removed] = result.splice(action.payload.startIndex, 1);
        result.splice(action.payload.endIndex, 0, removed);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      case IMPORT_ENTITIES: {
        const keys = Object.keys(action.payload.entities);
        const toReturn = { ...state };
        for (const key of keys) {
          toReturn[key] = {
            ...state[key] || {},
            ...action.payload.entities[key] || {}
          };
        }
        return toReturn;
      }
      case ADD_REFERENCE: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        const result = Array.from(entity[action.payload.key]);
        result.splice(action.payload.index || result.length + 1, 0, action.payload.reference);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      case REMOVE_REFERENCE: {
        if (!isReferenceList(state, action.payload.id, action.payload.type, action.payload.key)) {
          return state;
        }
        const entity = state[action.payload.type][action.payload.id];
        const result = Array.from(entity[action.payload.key]);
        const indexToRemove = action.payload.index || result.findIndex((e) => e && e.id === action.payload.reference.id);
        if (indexToRemove === -1) {
          return state;
        }
        if (result[indexToRemove]?.id !== action.payload.reference.id) {
          return state;
        }
        result.splice(indexToRemove, 1);
        return {
          ...state,
          [action.payload.type]: {
            ...state[action.payload.type],
            [action.payload.id]: {
              ...entity,
              [action.payload.key]: result
            }
          }
        };
      }
      default:
        return state;
    }
  };

  const requestReducer = (state = {}, action) => {
    switch (action.type) {
      case REQUEST_RESOURCE:
      case REQUEST_OFFLINE_RESOURCE:
        return {
          ...state,
          [action.payload.id]: {
            requestUri: action.payload.id,
            loadingState: RESOURCE_LOADING,
            uriMismatch: false,
            resourceUri: action.payload.id
          }
        };
      case REQUEST_MISMATCH:
        return {
          ...state,
          [action.payload.requestId]: {
            ...state[action.payload.requestId] || {},
            uriMismatch: true,
            resourceUri: action.payload.actualId
          },
          [action.payload.actualId]: {
            requestUri: action.payload.requestId,
            loadingState: state[action.payload.requestId].loadingState,
            uriMismatch: true,
            resourceUri: action.payload.actualId
          }
        };
      case REQUEST_ERROR:
        return {
          ...state,
          [action.payload.id]: {
            ...state[action.payload.id] || {},
            loadingState: RESOURCE_ERROR,
            error: action.payload.message
          }
        };
      case REQUEST_COMPLETE:
        return {
          ...state,
          [action.payload.id]: {
            ...state[action.payload.id] || {},
            loadingState: RESOURCE_READY,
            error: void 0
          }
        };
    }
    return state;
  };

  const metaReducer = (state = {}, action) => {
    const { id, updateValue, value, meta, key } = action && action.payload || {};
    switch (action.type) {
      case SET_META_VALUE: {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: value
            }
          }
        };
      }
      case SET_META_VALUE_DYNAMIC: {
        return {
          ...state,
          [id]: {
            ...state[id] || {},
            [meta]: {
              ...state[id] ? state[id][meta] || {} : {},
              [key]: state[id] && state[id][meta] ? updateValue(state[id][meta][key]) : updateValue(void 0)
            }
          }
        };
      }
      case UNSET_META_VALUE: {
        if (state[id] && state[id][meta] && state[id][meta][key]) {
          return {
            ...state,
            [id]: {
              ...state[id] || {},
              [meta]: {
                ...state[id] ? state[id][meta] || {} : {},
                [key]: void 0
              }
            }
          };
        }
        return state;
      }
      default:
        return state;
    }
  };

  function createBatchReducer(rootReducer) {
    return (state, action) => {
      if (action && action.type === BATCH_ACTIONS) {
        return action.payload.actions.reduce(rootReducer, state);
      }
      if (action && action.type === BATCH_IMPORT) {
        return action.payload.state;
      }
      return rootReducer(state, action);
    };
  }

  const reducers = combineReducers({
    mapping: mappingReducer,
    entities: entitiesReducer,
    requests: requestReducer,
    meta: metaReducer
  });
  const composeEnhancers = typeof window !== "undefined" ? window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose : compose;
  function createStore(options = {}) {
    const {
      enableDevtools = true,
      iiifStoreName = "iiif",
      defaultState = {},
      extraMiddleware = [],
      customReducers = {}
    } = options;
    const rootReducer = combineReducers({ [iiifStoreName]: reducers, ...customReducers });
    const store = createStore$1(createBatchReducer(rootReducer), defaultState, enableDevtools ? composeEnhancers(applyMiddleware(...extraMiddleware)) : compose(applyMiddleware(...extraMiddleware)));
    return store;
  }

  function mitt(n){return {all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e]);},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]));},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e);}),(i=n.get("*"))&&i.slice().map(function(n){n(t,e);});}}}

  class Vault {
    options;
    store;
    emitter;
    isBatching = false;
    batchQueue = [];
    remoteFetcher;
    staticFetcher;
    constructor(options, store) {
      this.options = Object.assign({
        reducers: {},
        middleware: [],
        defaultState: {},
        customFetcher: this.defaultFetcher,
        enableDevtools: true
      }, options || {});
      this.store = store || createStore({
        customReducers: this.options.reducers,
        extraMiddleware: [...this.options.middleware, this.middleware],
        defaultState: this.options.defaultState,
        enableDevtools: this.options.enableDevtools
      });
      this.emitter = mitt();
      this.remoteFetcher = createFetchHelper(this.store, this.options.customFetcher);
      this.staticFetcher = createFetchHelper(this.store, (id, json) => json);
    }
    defaultFetcher = (url) => {
      return fetch(url).then((r) => r.json());
    };
    batch(cb) {
      this.isBatching = true;
      try {
        cb(this);
        this.store.dispatch(batchActions({ actions: this.batchQueue }));
      } catch (e) {
        this.batchQueue = [];
        this.isBatching = false;
        throw e;
      }
      this.batchQueue = [];
      this.isBatching = false;
    }
    async asyncBatch(cb) {
      this.isBatching = true;
      try {
        await cb(this);
        this.store.dispatch(batchActions({ actions: this.batchQueue }));
      } catch (e) {
        this.batchQueue = [];
        this.isBatching = false;
        throw e;
      }
      this.batchQueue = [];
      this.isBatching = false;
    }
    modifyEntityField(entity, key, value) {
      this.dispatch(entityActions.modifyEntityField({
        id: entity.id,
        type: entity.type,
        key,
        value
      }));
    }
    dispatch(action) {
      if (!this.isBatching) {
        this.store.dispatch(action);
      } else {
        this.batchQueue.push(action);
      }
    }
    middleware = (store) => (next) => (action) => {
      if (action.type === BATCH_ACTIONS) {
        for (const realAction of action.payload.actions) {
          this.emitter.emit(realAction.type, { realAction, state: store.getState() });
        }
        const state2 = next(action);
        for (const realAction of action.payload.actions) {
          this.emitter.emit(`after:${action.type}`, { action, state: state2 });
        }
        return state2;
      }
      this.emitter.emit(action.type, { action, state: store.getState() });
      const state = next(action);
      this.emitter.emit(`after:${action.type}`, { action, state });
      return state;
    };
    serialize(entity, config) {
      return ct(this.getState().iiif, entity, config);
    }
    toPresentation2(entity) {
      return this.serialize(entity, ut);
    }
    toPresentation3(entity) {
      return this.serialize(entity, dt);
    }
    hydrate(reference, type) {
      return this.get(reference, type, { skipSelfReturn: false });
    }
    get(reference, type, options = {}) {
      if (typeof type !== "string") {
        options = type || {};
        type = void 0;
      }
      const { skipSelfReturn = true } = options || {};
      if (Array.isArray(reference)) {
        return reference.map((i) => this.get(i, options));
      }
      const state = this.getState();
      if (typeof reference === "string") {
        const _type2 = type ? type : state.iiif.mapping[reference];
        if (!_type2) {
          if (skipSelfReturn) {
            return null;
          }
          return { id: reference, type: "unknown" };
        }
        reference = { id: reference, type: _type2 };
      }
      const _type = type ? type : reference.type;
      const _id = reference.id;
      const entities = state.iiif.entities[_type];
      if (!entities) {
        const request = state.iiif.requests[_id];
        if (request && request.resourceUri !== _id) {
          return this.get(request.resourceUri, options);
        }
        if (skipSelfReturn) {
          return null;
        }
        return reference;
      }
      return entities[reference.id] || (skipSelfReturn ? null : reference);
    }
    select(selector) {
      return selector(this.getState());
    }
    getStore() {
      return this.store;
    }
    getState() {
      return this.store.getState();
    }
    loadManifest(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      return this.load(_id, json);
    }
    loadCollection(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      return this.load(_id, json);
    }
    load(id, json) {
      const _id = typeof id === "string" ? id : id.id;
      if (json) {
        return this.staticFetcher(_id, json);
      }
      return this.remoteFetcher(_id);
    }
    areInputsEqual(newInputs, lastInputs) {
      return areInputsEqual(newInputs, lastInputs);
    }
    subscribe(selector, subscription, skipInitial) {
      if (typeof skipInitial === "undefined" && (typeof subscription === "undefined" || subscription === false || subscription === true)) {
        skipInitial = subscription;
        subscription = selector;
        selector = (a) => a;
      }
      let lastState = skipInitial ? null : selector(this.store.getState());
      if (!skipInitial) {
        subscription(lastState, this);
      }
      return this.store.subscribe(() => {
        const state = this.store.getState();
        const selectedState = selector(state);
        if (lastState !== selectedState && !areInputsEqual(lastState, selectedState)) {
          subscription(selectedState, this);
        }
        lastState = selectedState;
      });
    }
    async ensureLoaded(_id) {
      const id = typeof _id === "string" ? _id : _id.id;
      if (!this.requestStatus(id)) {
        await this.load(id);
      }
    }
    requestStatus(id) {
      return this.select((state) => {
        return state.iiif.requests[id];
      });
    }
    getResourceMeta(resource, metaKey) {
      const resourceMeta = this.getState().iiif.meta[resource];
      if (!resourceMeta) {
        return void 0;
      }
      if (!metaKey) {
        return resourceMeta;
      }
      return resourceMeta[metaKey];
    }
    setMetaValue([id, meta, key], newValueOrUpdate) {
      this.dispatch(typeof newValueOrUpdate === "function" ? metaActions.setMetaValueDynamic({
        id,
        meta,
        key,
        updateValue: newValueOrUpdate
      }) : metaActions.setMetaValue({
        id,
        meta,
        key,
        value: newValueOrUpdate
      }));
    }
  }

  function getGlobal() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global !== "undefined") {
      return global;
    }
    return {};
  }

  function globalVault(options) {
    const g = getGlobal();
    try {
      const gv = g["IIIF_VAULT"];
      if (gv) {
        return gv;
      }
    } catch (e) {
    }
    const newVault = new Vault(options);
    try {
      g["IIIF_VAULT"] = newVault;
    } catch (e) {
    }
    return newVault;
  }

  exports.Vault = Vault;
  exports.globalVault = globalVault;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
